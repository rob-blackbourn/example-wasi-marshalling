(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.wasiMarshalling = {}));
}(this, (function (exports) { 'use strict';

  /**
   * Allocate memory
   * @callback malloc
   * @param {number} byteLength The number of bytes to allocate
   * @returns {number} The address of the allocatred memory
   */

   /**
    * Free allocated memory
    * @callback free
    * @param {number} address The address of the allocated memory
    */

  /**
   * The memory manager
   */
  class MemoryManager {
    /**
     * Construct a memory manager.
     * @param {WebAssembly.Memory} memory The memory fro the WebAssembly instance.
     * @param {malloc} malloc Allocate memory
     * @param {free} free Free memory
     */
    constructor (memory, malloc, free) {
      this.memory = memory;
      this.malloc = malloc;
      this.free = free;
      this._dataView = null;
    }

    /**
     * @poperty {DataView}
     */
    get dataView() {
      if (this._dataView == null || this._dataView.byteLength === 0) {
        this._dataView = new DataView(this.memory.buffer);
      }
      return this._dataView
    }
  }

  /**
   * The base class for representing types
   * @template T
   */
  class Type {
    /**
     * The abstract constructor for a type.
     * @param {Int8ArrayConstructor|Int16ArrayConstructor|Int32ArrayConstructor|BigInt64ArrayConstructor|Uint8ArrayConstructor|Uint16ArrayConstructor|Uint32ArrayConstructor|BigUint64ArrayConstructor|Float32ArrayConstructor|Float64ArrayConstructor} typedArrayType The typed array for the type
     */
    constructor (typedArrayType) {
      this.TypedArrayType = typedArrayType;
    }

    /**
     * Allocate memory for the type
     * @abstract
     * @param {MemoryManager} memoryManager The memory manager
     * @param {T} array An optional array
     * @returns {number} The address of the allocated value in memory
     */
    alloc (memoryManager, array) {
      throw new Error('Not Implemented')
    }

    /**
     * Free the memory for the value
     * @abstract
     * @param {number} address The address of the value in memory
     * @param {MemoryManager} memoryManager The memory manager
     * @param {T} [value] An optional unmarshalled value
     */
    free (address, memoryManager, value) {
      throw new Error('Not Implemented')
    }

    /**
     * Marshal a value.
     * @abstract
     * @param {T} value The value to marshall
     * @param {MemoryManager} memoryManager The memory manager
     * @returns {number|T} The marshalled value
     */
    marshall (value, memoryManager) {
      throw new Error('Not Implemented')
    }

    /**
     * Unmarshall a value.
     * @abstract
     * @param {number} address The address of the value in memory
     * @param {MemoryManager} memoryManager The memory manager
     * @param {T} [value] An optional unmarshalled value
     * @returns {T}
     */
    unmarshall (address, memoryManager, value) {
      throw new Error('Not Implemented')
    }

    /**
     * Copy a value
     * @abstract
     * @param {T} dest The destination value
     * @param {T} source The source value
     * @returns {T} The destination value
     */
    copy (dest, source) {
      throw new Error('Not Implemented')
    }
  }

  /**
   * A base class representing a value type
   * @template T
   * @extends {Type<T>}
   */
  class ValueType extends Type {
    /**
     * Allocate memory for the type
     * @param {MemoryManager} memoryManager The memory manager
     * @returns {number} The address of the allocated memory
     */
    alloc (memoryManager) {
      return memoryManager.malloc(this.TypedArrayType.BYTES_PER_ELEMENT)
    }

    /**
     * Free allocated memory
     * @param {number} address The address of the memory to be freed
     * @param {MemoryManager} memoryManager The memory manager
     * @param {T} [value] Optional unmarshalled value.
     */
    free (address, memoryManager, value) {
      memoryManager.free(address);
    }
  }

  /**
   * A type representing an 8 bit integer
   * @template {number} T
   * @extends {ValueType<T>}
   */
  class Int8Type extends ValueType {
    /**
     * Construct an 8 bit integer type
     */
    constructor () {
      super(Int8Array);
    }

    /**
     * Marshalls the value to a pointer
     * @param {T} value The value to marhsall
     * @param {MemoryManager} memoryManager The memory manager
     * @returns {number} The address of a pointer to the value
     */
    marshall (value, memoryManager) {
      const address = this.alloc(memoryManager);
      memoryManager.dataView.setInt8(address, value);
      return address
    }

    /**
     * Unmarshal the value from a pointer.
     * @param {number} address The address of the pointer to the value
     * @param {MemoryManager} memoryManager The memory manager
     * @param {T} [value] Optional unmarshalled value
     * @returns {T} The unmarshalled value.
     */
    unmarshall (address, memoryManager, value) {
      try {
        return /** @type {T} */ (memoryManager.dataView.getInt8(address))
      } finally {
        memoryManager.free(address);
      }
    }
  }

  /**
   * A type representing a 16 bit integer
   * @template {number} T
   * @extends {ValueType<T>}
   */
  class Int16Type extends ValueType {
    /**
     * Construct a 16 bit integer type
     */
    constructor () {
      super(Int8Array);
    }

    /**
     * Marshalls the value to a pointer
     * @param {T} value The value to marhsall
     * @param {MemoryManager} memoryManager The memory manager
     * @returns {number} The address of a pointer to the value
     */
    marshall (value, memoryManager) {
      const address = this.alloc(memoryManager);
      memoryManager.dataView.setInt16(address, value);
      return address
    }

    /**
     * Unmarshal the value from a pointer.
     * @param {number} address The address of the pointer to the value
     * @param {MemoryManager} memoryManager The memory manager
     * @param {T} [value] Optional unmarshalled value
     * @returns {T} The unmarshalled value.
     */
    unmarshall (address, memoryManager, value) {
      try {
        return /** @type {T} */ (memoryManager.dataView.getInt16(address))
      } finally {
        memoryManager.free(address);
      }
    }
  }

  /**
   * A type representing a 32 bit integer
   * @template {number} T
   * @extends {ValueType<T>}
   */
  class Int32Type extends ValueType {
    /**
     * Construct a 32 bit integer type
     */
    constructor () {
      super(Int32Array);
    }

    /**
     * Marshalls the value to a pointer
     * @param {T} value The value to marhsall
     * @param {MemoryManager} memoryManager The memory manager
     * @returns {number} The address of a pointer to the value
     */
    marshall (value, memoryManager) {
      const address = this.alloc(memoryManager);
      memoryManager.dataView.setInt32(address, value);
      return address
    }

    /**
     * Unmarshal the value from a pointer.
     * @param {number} address The address of the pointer to the value
     * @param {MemoryManager} memoryManager The memory manager
     * @param {T} [value] Optional unmarshalled value
     * @returns {T} The unmarshalled value.
     */
    unmarshall (address, memoryManager, value) {
      try {
        return /** @type {T} */ (memoryManager.dataView.getInt32(address))
      } finally {
        memoryManager.free(address);
      }
    }
  }

  /**
   * A type representing a 64 bit integer
   * @template {bigint} T
   * @extends {ValueType<T>}
   */
  class Int64Type extends ValueType {
    /**
     * Construct a 16 bit integer type
     */
    constructor () {
      super(BigInt64Array);
    }

    /**
     * Marshalls the value to a pointer
     * @param {T} value The value to marhsall
     * @param {MemoryManager} memoryManager The memory manager
     * @returns {number} The address of a pointer to the value
     */
    marshall (value, memoryManager) {
      const address = this.alloc(memoryManager);
      memoryManager.dataView.setBigInt64(address, value);
      return address
    }

    /**
     * Unmarshal the value from a pointer.
     * @param {number} address The address of the pointer to the value
     * @param {MemoryManager} memoryManager The memory manager
     * @param {T} [value] Optional unmarshalled value
     * @returns {T} The unmarshalled value.
     */
    unmarshall (address, memoryManager, value) {
      try {
        return /** @type {T} */ (memoryManager.dataView.getBigInt64(address))
      } finally {
        memoryManager.free(address);
      }
    }
  }

  /**
   * A type representing an 8 bit unsigned integer
   * @template {number} T
   * @extends {ValueType<T>}
   */
  class Uint8Type extends ValueType {
    /**
     * Construct an 8 bit unsigned integer type
     */
    constructor () {
      super(Uint8Array);
    }

    /**
     * Marshalls the value to a pointer
     * @param {T} value The value to marhsall
     * @param {MemoryManager} memoryManager The memory manager
     * @returns {number} The address of a pointer to the value
     */
    marshall (value, memoryManager) {
      const address = this.alloc(memoryManager);
      memoryManager.dataView.setUint8(address, value);
      return address
    }

    /**
     * Unmarshal the value from a pointer.
     * @param {number} address The address of the pointer to the value
     * @param {MemoryManager} memoryManager The memory manager
     * @param {T} [value] Optional unmarshalled value
     * @returns {T} The unmarshalled value.
     */
    unmarshall (address, memoryManager, value) {
      try {
        return /** @type {T} */ (memoryManager.dataView.getUint8(address))
      } finally {
        memoryManager.free(address);
      }
    }
  }

  /**
   * A type representing a 16 bit unsigned integer
   * @template {number} T
   * @extends {ValueType<T>}
   */
  class Uint16Type extends ValueType {
    /**
     * Construct a 16 bit unsigned integer type
     */
    constructor () {
      super(Uint16Array);
    }

    /**
     * Marshalls the value to a pointer
     * @param {T} value The value to marhsall
     * @param {MemoryManager} memoryManager The memory manager
     * @returns {number} The address of a pointer to the value
     */
    marshall (value, memoryManager) {
      const address = this.alloc(memoryManager);
      memoryManager.dataView.setUint16(address, value);
      return address
    }

    /**
     * Unmarshal the value from a pointer.
     * @param {number} address The address of the pointer to the value
     * @param {MemoryManager} memoryManager The memory manager
     * @param {T} [value] Optional unmarshalled value
     * @returns {T} The unmarshalled value.
     */
    unmarshall (address, memoryManager, value) {
      try {
        return /** @type {T} */ (memoryManager.dataView.getUint16(address))
      } finally {
        memoryManager.free(address);
      }
    }
  }

  /**
   * A type representing a 32 bit unsigned integer
   * @template {number} T
   * @extends {ValueType<T>}
   */
  class Uint32Type extends ValueType {
    /**
     * Construct a 32 bit unsigned integer type
     */
    constructor () {
      super(Uint32Array);
    }

    /**
     * Marshalls the value to a pointer
     * @param {T} value The value to marhsall
     * @param {MemoryManager} memoryManager The memory manager
     * @returns {number} The address of a pointer to the value
     */
    marshall (value, memoryManager) {
      const address = this.alloc(memoryManager);
      memoryManager.dataView.setUint32(address, value);
      return address
    }

    /**
     * Unmarshal the value from a pointer.
     * @param {number} address The address of the pointer to the value
     * @param {MemoryManager} memoryManager The memory manager
     * @param {T} [value] Optional unmarshalled value
     * @returns {T} The unmarshalled value.
     */
    unmarshall (address, memoryManager, value) {
      try {
        return /** @type {T} */ (memoryManager.dataView.getUint32(address))
      } finally {
        memoryManager.free(address);
      }
    }
  }

  /**
   * A type representing a 64 bit unsigned integer
   * @template {bigint} T
   * @extends {ValueType<T>}
   */
  class Uint64Type extends ValueType {
    /**
     * Construct a 64 bit unsigned integer type
     */
    constructor () {
      super(BigUint64Array);
    }

    /**
     * Marshalls the value to a pointer
     * @param {T} value The value to marhsall
     * @param {MemoryManager} memoryManager The memory manager
     * @returns {number} The address of a pointer to the value
     */
    marshall (value, memoryManager) {
      const address = this.alloc(memoryManager);
      memoryManager.dataView.setBigUint64(address, value);
      return address
    }

    /**
     * Unmarshal the value from a pointer.
     * @param {number} address The address of the pointer to the value
     * @param {MemoryManager} memoryManager The memory manager
     * @param {T} [value] Optional unmarshalled value
     * @returns {T} The unmarshalled value.
     */
    unmarshall (address, memoryManager, value) {
      try {
        return /** @type T */ (memoryManager.dataView.getBigUint64(address))
      } finally {
        memoryManager.free(address);
      }
    }
  }

  /**
   * A type representing a 64 bit float
   * @template {number} T
   * @extends {ValueType<T>}
   */
  class Float32Type extends ValueType {
    /**
     * Construct a 32 bit float type
     */
    constructor () {
      super(Float32Array);
    }

    /**
     * Marshalls the value to a pointer
     * @param {number} value The value to marhsall
     * @param {MemoryManager} memoryManager The memory manager
     * @returns {number} The address of a pointer to the value
     */
    marshall (value, memoryManager) {
      const address = this.alloc(memoryManager);
      memoryManager.dataView.setFloat32(address, value);
      return address
    }

    /**
     * Unmarshal the value from a pointer.
     * @param {number} address The address of the pointer to the value
     * @param {MemoryManager} memoryManager The memory manager
     * @param {T} [value] Optional unmarshalled value
     * @returns {T} The unmarshalled value.
     */
    unmarshall (address, memoryManager, value) {
      try {
        return /** @type {T} */ (memoryManager.dataView.getFloat32(address))
      } finally {
        memoryManager.free(address);
      }
    }
  }

  /**
   * A type representing a 64 bit float
   * @template {number} T
   * @extends {ValueType<T>}
   */
  class Float64Type extends ValueType {
    /**
     * Construct a 64 bit float type
     */
    constructor () {
      super(Float64Array);
    }

    /**
     * Marshalls the value to a pointer
     * @param {number} value The value to marhsall
     * @param {MemoryManager} memoryManager The memory manager
     * @returns {number} The address of a pointer to the value
     */
    marshall (value, memoryManager) {
      const address = this.alloc(memoryManager);
      memoryManager.dataView.setFloat64(address, value);
      return address
    }

    /**
     * Unmarshal the value from a pointer.
     * @param {number} address The address of the pointer to the value
     * @param {MemoryManager} memoryManager The memory manager
     * @param {T} [value] Optional unmarshalled value.
     * @returns {T} The unmarshalled value.
     */
    unmarshall (address, memoryManager, value) {
      try {
        return /** @type {T} */ (memoryManager.dataView.getFloat64(address))
      } finally {
        memoryManager.free(address);
      }
    }
  }

  /**
   * A class representing a reference type
   * @template T
   * @extends {Type<T>}
   */
  class ReferenceType extends Type {
    /**
     * Construct a reference type.
     */
    constructor () {
      super(Uint32Array);
    }
  }

  /**
   * A class representing a string type
   * @template {string} T
   * @extends {ReferenceType<string>}
   */
  class StringType extends ReferenceType {
    /**
     * Free an allocated string
     * @param {number} address The address of the string in memory
     * @param {MemoryManager} memoryManager The memory manager
     */
    free (address, memoryManager) {
      memoryManager.free(address);
    }

    /**
     * Marshall a string into memory
     * @param {T} string The string to marshall
     * @param {MemoryManager} memoryManager The memory manager
     * @returns {number} The address of the string in memory
     */
    marshall (string, memoryManager) {
      // Encode the string in utf-8.
      const encoder = new TextEncoder();
      const encodedString = encoder.encode(string);
      // Copy the string into memory allocated in the WebAssembly
      const address = memoryManager.malloc(encodedString.byteLength + 1);
      const buf = new Uint8Array(memoryManager.memory.buffer, address, encodedString.byteLength + 1);
      buf.set(encodedString);
      return address
    }

    /**
     * Unmarshall a string
     * @param {number} address The address of the string in memory
     * @param {MemoryManager} memoryManager The memory manager
     * @param {T} [value] Optional unmarshalled value.
     * @returns {T} The unmarshalled string
     */
    unmarshall (address, memoryManager, value) {
      try {
        // Find the number of bytes before the null termination character.
        const buf = new Uint8Array(memoryManager.memory.buffer, address);
        let length = 0;
        while (buf[length] !== 0) {
          ++length;
        }
        // Decode the string
        const array = new Uint8Array(memoryManager.memory.buffer, address, length);
        const decoder = new TextDecoder();
        const string = decoder.decode(array);
        return /** @type {T} */ (string)
      } finally {
        // Free the memory
        memoryManager.free(address);
      }
    }
  }

  /**
   * A pointer
   * @template T
   */
  class Pointer {
    /**
     * Construct a pointer.
     * @param {T} contents The contents of the pointer
     */
    constructor (contents) {
      this.contents = contents;
    }
  }

  /**
   * A pointer type
   * @template T
   * @extends {ReferenceType<Pointer<T>>}
   */
  class PointerType extends ReferenceType {
    /**
     * Construct a pointer type.
     * @param {Type<T>} type The type pointed to
     */
    constructor (type) {
      super();
      this.type = type;
    }

    /**
     * Free an allocated pointer
     * @param {number} address The address of the pointer to be freed
     * @param {MemoryManager} memoryManager The memory manager
     */
    free (address, memoryManager) {
      try {
        const marshalledAddress = memoryManager.dataView.getUint32(address);
        this.type.free(marshalledAddress, memoryManager);
      } finally {
        memoryManager.free(address);
      }
    }

    /**
     * Allocate memory for a pointer
     * @param {MemoryManager} memoryManager The memory manager
     * @returns{number} The address of the allocated memory
     */
    alloc (memoryManager) {
      const address = memoryManager.malloc(Uint32Array.BYTES_PER_ELEMENT);
      return address
    }

    /**
     * Marshal a pointer
     * @param {Pointer<T>} value The value to marshall
     * @param {MemoryManager} memoryManager The memory manager
     * @returns {number} The address of the pointer in memory
     */
    marshall (value, memoryManager) {
      const address = this.alloc(memoryManager);
      const marshalledAddress = /** @type {number} */ (this.type.marshall(value.contents, memoryManager));
      memoryManager.dataView.setUint32(address, marshalledAddress);
      return address
    }

    /**
     * 
     * @param {number} address The address of the pointer in memory
     * @param {MemoryManager} memoryManager The memory manager
     */
    unmarshall (address, memoryManager) {
      try {
        const marshalledAddress = memoryManager.dataView.getUint32(address);
        return new Pointer(this.type.unmarshall(marshalledAddress, memoryManager))
      } finally {
        memoryManager.free(address);
      }
    }

    /**
     * Copy a pointer
     * @param {Pointer<T>} dest The destination pointer
     * @param {Pointer<T>} source The source pointer
     * @returns {Pointer<T>} The destination pointer
     */
    copy (dest, source) {
      dest.contents = source.contents;
      return dest
    }
  }

  /**
   * An arra type
   * @template T
   * @extends {ReferenceType<Array<T>>}
   */
  class ArrayType extends ReferenceType {
    /**
     * Construct an array type
     * @param {Type<T>} type The type of the elements in the array
     * @param {number} length The length of the array
     */
    constructor (type, length) {
      super();
      this.type = type;
      this.length = length;
    }

    /**
     * Allocate memory for the array.
     * @param {MemoryManager} memoryManager The memory manager
     * @param {Array<T>} [array] An optional unmarshalled array
     * @returns {number} The address of the allocated memory.
     */
    alloc (memoryManager, array) {
      if (this.length != null && array != null && this.length !== array.length) {
        throw new RangeError('Invalid array length')
      }

      const length = array != null ? array.length : this.length;
      if (length == null) {
        throw new RangeError('Unknown length')
      }
      return memoryManager.malloc(length * this.type.TypedArrayType.BYTES_PER_ELEMENT)
    }

    /**
     * Fre allocated memory.
     * @param {number} address The address of the memory to be freed
     * @param {MemoryManager} memoryManager The memory manager
     * @param {Array<T>} [array] An optional unmarshalled array
     */
    free (address, memoryManager, array) {
      try {
        const length = array != null ? array.length : this.length;
        if (length == null) {
          throw new Error('Unknwon length for array')
        }
        if (this.type instanceof ReferenceType) {
          const typedArray = new this.type.TypedArrayType(memoryManager.memory.buffer, address, length);
          typedArray.forEach(item => this.type.free(item, memoryManager, null));
        }
      } finally {
        memoryManager.free(address);
      }
    }

    /**
     * Marshall a (possibly nested) array.
     * @param {Array<T>} array The array to be marshalled
     * @param {MemoryManager} memoryManager The memory manager
     * @returns {number} The address of the marshalled array
     */
    marshall (array, memoryManager) {
      const address = this.alloc(memoryManager, array);

      const typedArray = new this.type.TypedArrayType(memoryManager.memory.buffer, address, array.length);
      if (this.type instanceof ReferenceType) {
        array.forEach((item, i) => {
          typedArray[i] = /** @type {number} */ (this.type.marshall(item, memoryManager));
        });
      } else {
        // @ts-ignore
        typedArray.set(array);
      }

      return address
    }

    /**
     * Unmarshall a possibly nested array.
     * @param {number} address The address of the marshalled array
     * @param {MemoryManager} memoryManager The memory manager
     * @param {Array<T>} array AN optional unmarshalled array
     * @returns {Array<T>} The unmarshalled array
     */
    unmarshall (address, memoryManager, array) {
      try {
        const length = array != null ? array.length : this.length;
        if (length == null) {
          throw new Error('Unknwon length for array')
        }
        const typedArray = new this.type.TypedArrayType(memoryManager.memory.buffer, address, length);
        // @ts-ignore
        return this.type instanceof ReferenceType
          // @ts-ignore
          ? Array.from(typedArray, x => (this.type.unmarshall(x, memoryManager, null)))
          // @ts-ignore
          : Array.from(typedArray)
      } finally {
        memoryManager.free(address);
      }
    }

    /**
     * Copy an array
     * @param {Array<T>} dest The array to receive the data
     * @param {Array<T>} source The source array
     * @returns {Array<T>} The array to which the data was copied.
     */
    copy (dest, source) {
      dest.splice(0, dest.length, ...source);
      return dest
    }
  }

  /**
   * An argument definition is used by {@link FunctionPrototype} to define the
   * arguments to a function.
   * @template T
   */
  class ArgumentDef {
    /**
     * Construct an argument defintion. The {@link In}, {@link Out}, and {@link InOut}
     * helper classes should be used to construct argument definitions as they are
     * semantically clearer and avoid the possibility of setting both `isInput` and
     * `isOutput` to `false`.
     * @param {Type<T>} type The argument type
     * @param {boolean} isInput If true the argument provides data to the function
     * @param {boolean} isOutput If true the argument is poulated by the function
     */
    constructor (type, isInput, isOutput) {
      this.type = type;
      this.isInput = isInput;
      this.isOutput = isOutput;
    }

    /**
     * Create a representation of the JavaScript value which can be passed to a
     * WebAssembly module instance. For value types this is typically the value
     * itself. For refrence types memory will be allocated in the instance, and
     * the data will be copied.
     * @param {T} value The value for which a WebAssembly value should be created
     * @param {MemoryManager} memoryManager A class which provides methods to
     *    manage the memory of a WebAssembly module.
     * @returns {number|T} The address of the allocated memory or the marshalled value.
     */
    marshall (value, memoryManager) {
      if (this.type instanceof ValueType) {
        return value
      } else if (this.isInput) {
        return this.type.marshall(value, memoryManager)
      } else {
        return this.type.alloc(memoryManager, value)
      }
    }

    /**
     * Unmarshall a value
     * @param {number|T} addressOrValue The marshalled address or value 
     * @param {MemoryManager} memoryManager The memory manager
     * @param {T} [value] The optional unmarshalled value. 
     * @returns {number|T} The unmarshalled value.
     */
    unmarshall (addressOrValue, memoryManager, value) {
      if (this.type instanceof ValueType) {
        return addressOrValue
      }

      if (this.isOutput) {
        if (value == null) {
          throw new Error('Out put argument missing')
        }
        if (typeof addressOrValue !== 'number') {
          throw new Error('Expected address to be a number')
        }
        const result = this.type.unmarshall(addressOrValue, memoryManager, value);
        this.type.copy(value, result);
      } else {
        if (typeof addressOrValue !== 'number') {
          throw new Error('Expected address to be a number')
        }
        this.type.free(addressOrValue, memoryManager, value);
      }
    }
  }

  /**
   * An input arguent
   * @template T
   * @extends {ArgumentDef<T>}
   */
  class In extends ArgumentDef {
    /**
     * Construct an input argument
     * @param {Type<T>} type The argument type
     */
    constructor (type) {
      super(type, true, false);
    }
  }

  /**
   * An output argument
   * @template T
   * @extends {ArgumentDef<T>}
   */
  class Out extends ArgumentDef {
    /**
     * Construct an output argument
     * @param {Type<T>} type The argument type
     */
    constructor (type) {
      super(type, false, true);
    }
  }

  /**
   * An input/output argument
   * @template T
   * @extends {ArgumentDef<T>}
   */
  class InOut extends ArgumentDef {
    /**
     * Construct an input/output argument
     * @param {Type<T>} type The argument type
     */
    constructor (type) {
      super(type, true, true);
    }
  }

  /**
   * A function prototype
   * @template T
   */
  class FunctionPrototype {
    /**
     * Construct a function prototype.
     * @param {Array<ArgumentDef<any>>} argDefs The argument definitions
     * @param {Type<T>} [returns] An optional return type
     */
    constructor (argDefs, returns) {
      this.argDefs = argDefs;
      this.returns = returns;
    }

    /**
     * Invoke a function
     * @param {MemoryManager} memoryManager The memory manager
     * @param {Function} func The function to invoke
     * @param {Array<any>} args The function arguments
     * @returns {T} An optional return value
     */
    invoke (memoryManager, func, ...args) {
      if (this.argDefs.length !== args.length) {
        throw new RangeError('Invalid number of arguments')
      }

      const marshalledArgs = args.map((arg, i) =>
        this.argDefs[i].marshall(arg, memoryManager));

      const result = func(...marshalledArgs);

      args.forEach((arg, i) =>
        this.argDefs[i].unmarshall(marshalledArgs[i], memoryManager, arg));

      if (this.returns != null) {
        return this.returns.unmarshall(result, memoryManager)
      }
    }
  }

  const WASI = {
    // No error occurred. System call completed successfully.
    ESUCCESS: 0,

    // Error codes
    ERRNO: {
      // Argument list too long.
      '2BIG': 1,

      // Permission denied.
      ACCES: 2,

      // Address in use.
      ADDRINUSE: 3,

      // Address not available.
      ADDRNOTAVAIL: 4,

      // Address family not supported.
      AFNOSUPPORT: 5,

      // Resource unavailable, or operation would block.
      AGAIN: 6,

      // Connection already in progress.
      ALREADY: 7,

      // Bad file descriptor.
      BADF: 8,

      // Bad message.
      BADMSG: 9,

      // Device or resource busy.
      BUSY: 10,

      // Operation canceled.
      CANCELED: 11,

      // No child processes.
      CHILD: 12,

      // Connection aborted.
      CONNABORTED: 13,

      // Connection refused.
      CONNREFUSED: 14,

      // Connection reset.
      CONNRESET: 15,

      // Resource deadlock would occur.
      DEADLK: 16,

      // Destination address required.
      DESTADDRREQ: 17,

      // Mathematics argument out of domain of function.
      DOM: 18,

      // Reserved.
      DQUOT: 19,

      // File exists.
      EXIST: 20,

      // Bad address.
      FAULT: 21,

      // File too large.
      FBIG: 22,

      // Host is unreachable.
      HOSTUNREACH: 23,

      // Identifier removed.
      IDRM: 24,

      // Illegal byte sequence.
      ILSEQ: 25,

      // Operation in progress.
      INPROGRESS: 26,

      // Interrupted function.
      INTR: 27,

      // Invalid argument.
      INVAL: 28,

      // I/O error.
      IO: 29,

      // Socket is connected.
      ISCONN: 30,

      // Is a directory.
      ISDIR: 31,

      // Too many levels of symbolic links.
      LOOP: 32,

      // File descriptor value too large.
      MFILE: 33,

      // Too many links.
      MLINK: 34,

      // Message too large.
      MSGSIZE: 35,

      // Reserved.
      MULTIHOP: 36,

      // Filename too long.
      NAMETOOLONG: 37,

      // Network is down.
      NETDOWN: 38,

      // Connection aborted by network.
      NETRESET: 39,

      // Network unreachable.
      NETUNREACH: 40,

      // Too many files open in system.
      NFILE: 41,

      // No buffer space available.
      NOBUFS: 42,

      // No such device.
      NODEV: 43,

      // No such file or directory.
      NOENT: 44,

      // Executable file format error.
      NOEXEC: 45,

      // No locks available.
      NOLCK: 46,

      // Reserved.
      NOLINK: 47,

      // Not enough space.
      NOMEM: 48,

      // No message of the desired type.
      NOMSG: 49,

      // Protocol not available.
      NOPROTOOPT: 50,

      // No space left on device.
      NOSPC: 51,

      // Function not supported.
      NOSYS: 52,

      // The socket is not connected.
      NOTCONN: 53,

      // Not a directory or a symbolic link to a directory.
      NOTDIR: 54,

      // Directory not empty.
      NOTEMPTY: 55,

      // State not recoverable.
      NOTRECOVERABLE: 56,

      // Not a socket.
      NOTSOCK: 57,

      // Not supported, or operation not supported on socket.
      NOTSUP: 58,

      // Inappropriate I/O control operation.
      NOTTY: 59,

      // No such device or address.
      NXIO: 60,

      // Value too large to be stored in data type.
      OVERFLOW: 61,

      // Previous owner died.
      OWNERDEAD: 62,

      // Operation not permitted.
      PERM: 63,

      // Broken pipe.
      PIPE: 64,

      // Protocol error.
      PROTO: 65,

      // Protocol not supported.
      PROTONOSUPPORT: 66,

      // Protocol wrong type for socket.
      PROTOTYPE: 67,

      // Result too large.
      RANGE: 68,

      // Read-only file system.
      ROFS: 69,

      // Invalid seek.
      SPIPE: 70,

      // No such process.
      SRCH: 71,

      // Reserved.
      STALE: 72,

      // Connection timed out.
      TIMEDOUT: 73,

      // Text file busy.
      TXTBSY: 74,

      // Cross-device link.
      XDEV: 75,

      // Extension: Capabilities insufficient.
      NOTCAPABLE: 76

    },
    FILETYPE: {
      UNKNOWN: 0,
      BLOCK_DEVICE: 1,
      CHARACTER_DEVICE: 2,
      DIRECTORY: 3,
      REGULAR_FILE: 4,
      SOCKET_DGRAM: 5,
      SOCKET_STREAM: 6,
      SYMBOLIC_LINK: 7
    },

    // Flags for files descriptors.
    FDFLAGS: {
      // Append mode: Data written to the file is always appended to the file's end.
      APPEND: 1,

      // Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized.
      DSYNC: 2,

      // Non-blocking mode.
      NONBLOCK: 4,

      // Synchronized read I/O operations.
      RSYNC: 8,

      // Write according to synchronized I/O file integrity completion. In
      // addition to synchronizing the data stored in the file, the implementation
      // may also synchronously update the file's metadata.
      SYNC: 16
    },

    // Flags for rights
    RIGHTS: {
      FD: {
        DATASYNC: 1n,
        READ: 2n,
        SEEK: 4n,
        FDSTAT_SET_FLAGS: 8n,
        SYNC: 16n,
        TELL: 32n,
        WRITE: 64n,
        ADVISE: 128n,
        ALLOCATE: 256n,
        READDIR: 16384n,
        FILESTAT_GET: 2097152n,
        FILESTAT_SET_SIZE: 4194304n,
        FILESTAT_SET_TIMES: 8388608n
      },
      PATH: {
        CREATE_DIRECTORY: 512n,
        CREATE_FILE: 1024n,
        LINK_SOURCE: 2048n,
        LINK_TARGET: 4096n,
        OPEN: 8192n,
        READLINK: 32768n,
        RENAME_SOURCE: 65536n,
        RENAME_TARGET: 131072n,
        FILESTAT_GET: 262144n,
        FILESTAT_SET_SIZE: 524288n,
        FILESTAT_SET_TIMES: 1048576n,
        SYMLINK: 16777216n,
        REMOVE_DIRECTORY: 33554432n,
        UNLINK_FILE: 67108864n
      },
      POLL_FD_READWRITE: 134217728n,
      SOCK_SHUTDOWN: 268435456n
    },
    ADVICE: {
      // The application has no advice to give on its behavior with respect to the specified data.
      NORMAL: 0,

      // The application expects to access the specified data sequentially from lower offsets to higher offsets.
      SEQUENTIAL: 1,

      // The application expects to access the specified data in a random order.
      RANDOM: 2,

      // The application expects to access the specified data in the near future.
      WILLNEED: 3,

      // The application expects that it will not access the specified data in the near future.
      DONTNEED: 4,

      // The application expects to access the specified data once and then not reuse it thereafter.
      NOREUSE: 5
    }
  };

  const STDOUT = 1;
  const STDERR = 2;

  /**
   * Write
   * @callback writeCallback
   * @param {string} text 
   */

   /**
   * Allocate memory
   * @callback malloc
   * @param {number} byteLength The number of bytes to allocate
   * @returns {number} The address of the allocatred memory
   */

   /**
    * Free allocated memory
    * @callback free
    * @param {number} address The address of the allocated memory
    */

  /**
   * Drain the write if a newline is in the latest test.
   * @private
   * @param {writeCallback} write A function to write a complete line
   * @param {string} prev The previous text
   * @param {string} current The latest text
   */
  function drainWriter(write, prev, current) {
    let text = prev + current;
    while (text.includes('\n')) {
      const [line, rest] = text.split('\n', 2);
      write(line);
      text = rest;
    }
    return text
  }

  /**
   * An implementation of WASI which supports the minimum required to memory
   * allocation, stdio and multi byte (UTF-8) characters.
   */
  class Wasi {
    /**
     * Create a Wasi class
     * @param {Object.<string, string>} env The environmanet variables
     */
    constructor(env) {
      this.env = env;
      /**
       * @property {WebAssembly.Instance} [instance] The WebAssembly instance.
       */
      this.instance = null;
      /**
       * @property {MemoryManager} [memoryManager] The WebAssembly memory manager
       */
      this.memoryManager = null;
      /**
       * @private
       * @property {string} Text sent to stdout before a newline has een received.
       */
      this.stdoutText = '';
      /**
       * @private
       * @property {string} Text sent to stderr before a newline has een received.
       */
      this.stderrText = '';
    }

    // Initialise the instance from the WebAssembly.
    /**
     * Initialise the WASI class with a WebAssembly instance.
     * @param {WebAssembly.Instance} instance A WebAssembly instance
     */
    init(instance) {
      this.instance = instance;
      this.memoryManager = new MemoryManager(
        /** @type {WebAssembly.Memory} */ (instance.exports.memory),
        /** @type {malloc} */ (instance.exports.malloc),
        /** @type {free} */ (instance.exports.free));
    }

    /**
     * Get the environment variables.
     * @param {number} environ The environment
     * @param {number} environBuf The address of the buffer
     */
    environ_get(environ, environBuf) {
      const encoder = new TextEncoder();

      Object.entries(this.env).map(
        ([key, value]) => `${key}=${value}`
      ).forEach(envVar => {
        this.memoryManager.dataView.setUint32(environ, environBuf, true);
        environ += 4;

        const bytes = encoder.encode(envVar);
        const buf = new Uint8Array(this.memoryManager.memory.buffer, environBuf, bytes.length + 1);
        environBuf += buf.byteLength;
      });
      return WASI.ESUCCESS
    }

    /**
     * Get the size required to store the environment variables.
     * @param {number} environCount The number of environment variables
     * @param {number} environBufSize The size of the environment variables bufer
     */
    environ_sizes_get(environCount, environBufSize) {
      const encoder = new TextEncoder();

      const envVars = Object.entries(this.env).map(
        ([key, value]) => `${key}=${value}`
      );
      const size = envVars.reduce(
        (acc, envVar) => acc + encoder.encode(envVar).byteLength + 1,
        0
      );
      this.memoryManager.dataView.setUint32(environCount, envVars.length, true);
      this.memoryManager.dataView.setUint32(environBufSize, size, true);

      return WASI.ESUCCESS
    }

    /**
     * This gets called on exit to stop the running program. We don't have
     * anything to stop!
     * @param {number} rval The return value
     */
    proc_exit(rval) {
      return WASI.ESUCCESS
    }

    /**
     * Open the file desriptor
     * @param {number} fd The file descriptor
     */
    fd_close(fd) {
      return WASI.ESUCCESS
    }

    /**
     * Seek
     * @param {number} fd The file descriptor
     * @param {number} offset_low The low offset
     * @param {number} offset_high The high offset
     * @param {number} whence Whence
     * @param {number} newOffset The new offset
     */
    fd_seek(fd, offset_low, offset_high, whence, newOffset) {
      return WASI.ESUCCESS
    }

    /**
     * Write to a file descriptor
     * @param {number} fd The file descriptor
     * @param {number} iovs The address of the scatter vector
     * @param {number} iovsLen The length of the scatter vector
     * @param {number} nwritten The number of items written
     */
    fd_write(fd, iovs, iovsLen, nwritten) {
      if (!(fd === 1 || fd === 2)) {
        return WASI.ERRNO.BADF
      }

      const buffers = Array.from({ length: iovsLen }, (_, i) => {
        const ptr = iovs + i * 8;
        const buf = this.memoryManager.dataView.getUint32(ptr, true);
        const bufLen = this.memoryManager.dataView.getUint32(ptr + 4, true);
        return new Uint8Array(this.memoryManager.memory.buffer, buf, bufLen)
      });

      const textDecoder = new TextDecoder();

      let written = 0;
      let text = '';
      buffers.forEach(buf => {
        text += textDecoder.decode(buf);
        written += buf.byteLength;
      });
      this.memoryManager.dataView.setUint32(nwritten, written, true);

      if (fd === STDOUT) {
        this.stdoutText = drainWriter(console.log, this.stdoutText, text);
      } else if (fd === STDERR) {
        this.stderrText = drainWriter(console.error, this.stderrText, text);
      }

      return WASI.ESUCCESS
    }

    /**
     * Get the status of a file descriptor
     * @param {number} fd The file descriptor
     * @param {number} stat The status
     */
    fd_fdstat_get(fd, stat) {
      if (!(fd === 1 || fd === 2)) {
        return WASI.ERRNO.BADF
      }
      if (this.memoryManager == null || this.memoryManager.dataView == undefined) {
        throw new Error('No memory')
      }

      this.memoryManager.dataView.setUint8(stat + 0, WASI.FILETYPE.CHARACTER_DEVICE);
      this.memoryManager.dataView.setUint32(stat + 2, WASI.FDFLAGS.APPEND, true);
      this.memoryManager.dataView.setBigUint64(stat + 8, WASI.RIGHTS.FD.WRITE, true);
      this.memoryManager.dataView.setBigUint64(stat + 16, WASI.RIGHTS.FD.WRITE, true);
      return WASI.ESUCCESS
    }

    imports() {
      return {
        environ_get: (environ, environBuf) => this.environ_get(environ, environBuf),
        environ_sizes_get: (environCount, environBufSize) => this.environ_sizes_get(environCount, environBufSize),
        proc_exit: rval => this.proc_exit(rval),
        fd_close: fd => this.fd_close(fd),
        fd_seek: (fd, offset_low, offset_high, whence, newOffset) => this.fd_seek(fd, offset_low, offset_high, whence, newOffset),
        fd_write: (fd, iovs, iovsLen, nwritten) => this.fd_write(fd, iovs, iovsLen, nwritten),
        fd_fdstat_get: (fd, stat) => this.fd_fdstat_get(fd, stat)
      }
    }
  }

  exports.ArgumentDef = ArgumentDef;
  exports.ArrayType = ArrayType;
  exports.Float32Type = Float32Type;
  exports.Float64Type = Float64Type;
  exports.FunctionPrototype = FunctionPrototype;
  exports.In = In;
  exports.InOut = InOut;
  exports.Int16Type = Int16Type;
  exports.Int32Type = Int32Type;
  exports.Int64Type = Int64Type;
  exports.Int8Type = Int8Type;
  exports.MemoryManager = MemoryManager;
  exports.Out = Out;
  exports.Pointer = Pointer;
  exports.PointerType = PointerType;
  exports.ReferenceType = ReferenceType;
  exports.StringType = StringType;
  exports.Type = Type;
  exports.Uint16Type = Uint16Type;
  exports.Uint32Type = Uint32Type;
  exports.Uint64Type = Uint64Type;
  exports.Uint8Type = Uint8Type;
  exports.ValueType = ValueType;
  exports.Wasi = Wasi;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
