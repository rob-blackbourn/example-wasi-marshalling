(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["WasiMarshalling"] = factory();
	else
		root["WasiMarshalling"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/flow-bin/index.js":
/*!****************************************!*\
  !*** ./node_modules/flow-bin/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, __dirname) {/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var VERSION = __webpack_require__(/*! ./package.json */ "./node_modules/flow-bin/package.json").version;

var path = __webpack_require__(/*! path */ "./node_modules/path-browserify/index.js");

module.exports =
  process.platform === 'darwin'
    ? path.join(__dirname, 'flow-osx-v' + VERSION, 'flow') :
  process.platform === 'linux' && process.arch === 'x64'
    ? path.join(__dirname, 'flow-linux64-v' + VERSION, 'flow') :
  process.platform === 'win32' &&  process.arch === 'x64'
    ? path.join(__dirname, 'flow-win64-v' + VERSION, 'flow.exe') :
  null;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js"), "/"))

/***/ }),

/***/ "./node_modules/flow-bin/package.json":
/*!********************************************!*\
  !*** ./node_modules/flow-bin/package.json ***!
  \********************************************/
/*! exports provided: _args, _development, _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _spec, _where, author, bin, bugs, description, engines, files, homepage, keywords, license, name, repository, scripts, version, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"_args\":[[\"flow-bin@0.128.0\",\"/home/rtb/dev/public/rob-blackbourn/jetblack-wasi-marshaller\"]],\"_development\":true,\"_from\":\"flow-bin@0.128.0\",\"_id\":\"flow-bin@0.128.0\",\"_inBundle\":false,\"_integrity\":\"sha512-EnmMSOCrkx8F0r1+T1d1HODQ+ddy5yRfkT3CvwmK05IWZyXQy27OVdNwdXUWRqc0iMW75T4QkoXaVBYrMqfk+A==\",\"_location\":\"/flow-bin\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"version\",\"registry\":true,\"raw\":\"flow-bin@0.128.0\",\"name\":\"flow-bin\",\"escapedName\":\"flow-bin\",\"rawSpec\":\"0.128.0\",\"saveSpec\":null,\"fetchSpec\":\"0.128.0\"},\"_requiredBy\":[\"#DEV:/\"],\"_resolved\":\"https://registry.npmjs.org/flow-bin/-/flow-bin-0.128.0.tgz\",\"_spec\":\"0.128.0\",\"_where\":\"/home/rtb/dev/public/rob-blackbourn/jetblack-wasi-marshaller\",\"author\":{\"name\":\"Sindre Sorhus\",\"email\":\"sindresorhus@gmail.com\",\"url\":\"sindresorhus.com\"},\"bin\":{\"flow\":\"cli.js\"},\"bugs\":{\"url\":\"https://github.com/flowtype/flow-bin/issues\"},\"description\":\"Binary wrapper for Flow - A static type checker for JavaScript\",\"engines\":{\"node\":\">=0.10.0\"},\"files\":[\"flow-linux64-v*/flow\",\"flow-osx-v*/flow\",\"flow-win64-v*/flow.exe\",\"vendor\",\"cli.js\",\"index.js\",\"SHASUM256.txt\"],\"homepage\":\"https://github.com/flowtype/flow-bin#readme\",\"keywords\":[\"cli-app\",\"cli\",\"bin\",\"binary\",\"flow\",\"facebook\",\"type\",\"inference\",\"check\",\"checker\",\"javascript\",\"js\",\"wrapper\"],\"license\":\"MIT\",\"name\":\"flow-bin\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/flowtype/flow-bin.git\"},\"scripts\":{\"test\":\"echo \\\"Error: Run 'make test' instead.\\\" && exit 1\",\"verify\":\"shasum -c SHASUM256.txt\"},\"version\":\"0.128.0\"}");

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./src/MemoryManager.js":
/*!******************************!*\
  !*** ./src/MemoryManager.js ***!
  \******************************/
/*! exports provided: MemoryManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MemoryManager", function() { return MemoryManager; });
/* harmony import */ var flow_bin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flow-bin */ "./node_modules/flow-bin/index.js");
/* harmony import */ var flow_bin__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(flow_bin__WEBPACK_IMPORTED_MODULE_0__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }


var MemoryManager = function MemoryManager(memory, malloc, free) {
  _classCallCheck(this, MemoryManager);

  this.memory = memory;
  this.malloc = malloc;
  this.free = free;
  this.dataView = new DataView(this.memory.buffer);
};

/***/ }),

/***/ "./src/constants.js":
/*!**************************!*\
  !*** ./src/constants.js ***!
  \**************************/
/*! exports provided: WASI, STDOUT, STDERR */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WASI", function() { return WASI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STDOUT", function() { return STDOUT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STDERR", function() { return STDERR; });
var WASI = {
  // No error occurred. System call completed successfully.
  ESUCCESS: 0,
  // Error codes
  ERRNO: {
    // Argument list too long.
    '2BIG': 1,
    // Permission denied.
    ACCES: 2,
    // Address in use.
    ADDRINUSE: 3,
    // Address not available.
    ADDRNOTAVAIL: 4,
    // Address family not supported.
    AFNOSUPPORT: 5,
    // Resource unavailable, or operation would block.
    AGAIN: 6,
    // Connection already in progress.
    ALREADY: 7,
    // Bad file descriptor.
    BADF: 8,
    // Bad message.
    BADMSG: 9,
    // Device or resource busy.
    BUSY: 10,
    // Operation canceled.
    CANCELED: 11,
    // No child processes.
    CHILD: 12,
    // Connection aborted.
    CONNABORTED: 13,
    // Connection refused.
    CONNREFUSED: 14,
    // Connection reset.
    CONNRESET: 15,
    // Resource deadlock would occur.
    DEADLK: 16,
    // Destination address required.
    DESTADDRREQ: 17,
    // Mathematics argument out of domain of function.
    DOM: 18,
    // Reserved.
    DQUOT: 19,
    // File exists.
    EXIST: 20,
    // Bad address.
    FAULT: 21,
    // File too large.
    FBIG: 22,
    // Host is unreachable.
    HOSTUNREACH: 23,
    // Identifier removed.
    IDRM: 24,
    // Illegal byte sequence.
    ILSEQ: 25,
    // Operation in progress.
    INPROGRESS: 26,
    // Interrupted function.
    INTR: 27,
    // Invalid argument.
    INVAL: 28,
    // I/O error.
    IO: 29,
    // Socket is connected.
    ISCONN: 30,
    // Is a directory.
    ISDIR: 31,
    // Too many levels of symbolic links.
    LOOP: 32,
    // File descriptor value too large.
    MFILE: 33,
    // Too many links.
    MLINK: 34,
    // Message too large.
    MSGSIZE: 35,
    // Reserved.
    MULTIHOP: 36,
    // Filename too long.
    NAMETOOLONG: 37,
    // Network is down.
    NETDOWN: 38,
    // Connection aborted by network.
    NETRESET: 39,
    // Network unreachable.
    NETUNREACH: 40,
    // Too many files open in system.
    NFILE: 41,
    // No buffer space available.
    NOBUFS: 42,
    // No such device.
    NODEV: 43,
    // No such file or directory.
    NOENT: 44,
    // Executable file format error.
    NOEXEC: 45,
    // No locks available.
    NOLCK: 46,
    // Reserved.
    NOLINK: 47,
    // Not enough space.
    NOMEM: 48,
    // No message of the desired type.
    NOMSG: 49,
    // Protocol not available.
    NOPROTOOPT: 50,
    // No space left on device.
    NOSPC: 51,
    // Function not supported.
    NOSYS: 52,
    // The socket is not connected.
    NOTCONN: 53,
    // Not a directory or a symbolic link to a directory.
    NOTDIR: 54,
    // Directory not empty.
    NOTEMPTY: 55,
    // State not recoverable.
    NOTRECOVERABLE: 56,
    // Not a socket.
    NOTSOCK: 57,
    // Not supported, or operation not supported on socket.
    NOTSUP: 58,
    // Inappropriate I/O control operation.
    NOTTY: 59,
    // No such device or address.
    NXIO: 60,
    // Value too large to be stored in data type.
    OVERFLOW: 61,
    // Previous owner died.
    OWNERDEAD: 62,
    // Operation not permitted.
    PERM: 63,
    // Broken pipe.
    PIPE: 64,
    // Protocol error.
    PROTO: 65,
    // Protocol not supported.
    PROTONOSUPPORT: 66,
    // Protocol wrong type for socket.
    PROTOTYPE: 67,
    // Result too large.
    RANGE: 68,
    // Read-only file system.
    ROFS: 69,
    // Invalid seek.
    SPIPE: 70,
    // No such process.
    SRCH: 71,
    // Reserved.
    STALE: 72,
    // Connection timed out.
    TIMEDOUT: 73,
    // Text file busy.
    TXTBSY: 74,
    // Cross-device link.
    XDEV: 75,
    // Extension: Capabilities insufficient.
    NOTCAPABLE: 76
  },
  FILETYPE: {
    UNKNOWN: 0,
    BLOCK_DEVICE: 1,
    CHARACTER_DEVICE: 2,
    DIRECTORY: 3,
    REGULAR_FILE: 4,
    SOCKET_DGRAM: 5,
    SOCKET_STREAM: 6,
    SYMBOLIC_LINK: 7
  },
  // Flags for files descriptors.
  FDFLAGS: {
    // Append mode: Data written to the file is always appended to the file's end.
    APPEND: 1,
    // Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized.
    DSYNC: 2,
    // Non-blocking mode.
    NONBLOCK: 4,
    // Synchronized read I/O operations.
    RSYNC: 8,
    // Write according to synchronized I/O file integrity completion. In
    // addition to synchronizing the data stored in the file, the implementation
    // may also synchronously update the file's metadata.
    SYNC: 16
  },
  // Flags for rights
  RIGHTS: {
    FD: {
      DATASYNC: 1n,
      READ: 2n,
      SEEK: 4n,
      FDSTAT_SET_FLAGS: 8n,
      SYNC: 16n,
      TELL: 32n,
      WRITE: 64n,
      ADVISE: 128n,
      ALLOCATE: 256n,
      READDIR: 16384n,
      FILESTAT_GET: 2097152n,
      FILESTAT_SET_SIZE: 4194304n,
      FILESTAT_SET_TIMES: 8388608n
    },
    PATH: {
      CREATE_DIRECTORY: 512n,
      CREATE_FILE: 1024n,
      LINK_SOURCE: 2048n,
      LINK_TARGET: 4096n,
      OPEN: 8192n,
      READLINK: 32768n,
      RENAME_SOURCE: 65536n,
      RENAME_TARGET: 131072n,
      FILESTAT_GET: 262144n,
      FILESTAT_SET_SIZE: 524288n,
      FILESTAT_SET_TIMES: 1048576n,
      SYMLINK: 16777216n,
      REMOVE_DIRECTORY: 33554432n,
      UNLINK_FILE: 67108864n
    },
    POLL_FD_READWRITE: 134217728n,
    SOCK_SHUTDOWN: 268435456n
  },
  ADVICE: {
    // The application has no advice to give on its behavior with respect to the specified data.
    NORMAL: 0,
    // The application expects to access the specified data sequentially from lower offsets to higher offsets.
    SEQUENTIAL: 1,
    // The application expects to access the specified data in a random order.
    RANDOM: 2,
    // The application expects to access the specified data in the near future.
    WILLNEED: 3,
    // The application expects that it will not access the specified data in the near future.
    DONTNEED: 4,
    // The application expects to access the specified data once and then not reuse it thereafter.
    NOREUSE: 5
  }
};
var STDOUT = 1;
var STDERR = 2;

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: MemoryManager, Type, ValueType, Int8Type, Int16Type, Int32Type, Int64Type, Uint8Type, Uint16Type, Uint32Type, Uint64Type, Float32Type, Float64Type, ReferenceType, StringType, Pointer, PointerType, ArrayType, ArgumentDef, In, Out, InOut, FunctionPrototype, Wasi */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MemoryManager */ "./src/MemoryManager.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MemoryManager", function() { return _MemoryManager__WEBPACK_IMPORTED_MODULE_0__["MemoryManager"]; });

/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./src/types/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Type", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["Type"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ValueType", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["ValueType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int8Type", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["Int8Type"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int16Type", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["Int16Type"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int32Type", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["Int32Type"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int64Type", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["Int64Type"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint8Type", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["Uint8Type"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint16Type", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["Uint16Type"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint32Type", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["Uint32Type"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint64Type", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["Uint64Type"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float32Type", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["Float32Type"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float64Type", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["Float64Type"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ReferenceType", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StringType", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["StringType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Pointer", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["Pointer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointerType", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["PointerType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ArrayType", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["ArrayType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ArgumentDef", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["ArgumentDef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "In", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["In"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Out", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["Out"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InOut", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["InOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FunctionPrototype", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["FunctionPrototype"]; });

/* harmony import */ var _wasi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wasi */ "./src/wasi.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Wasi", function() { return _wasi__WEBPACK_IMPORTED_MODULE_2__["Wasi"]; });





/***/ }),

/***/ "./src/types/ArgumentDef.js":
/*!**********************************!*\
  !*** ./src/types/ArgumentDef.js ***!
  \**********************************/
/*! exports provided: ArgumentDef */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArgumentDef", function() { return ArgumentDef; });
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MemoryManager */ "./src/MemoryManager.js");
/* harmony import */ var _ValueType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ValueType */ "./src/types/ValueType.js");
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Type */ "./src/types/Type.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




/**
 * An argument definition is used by {@link FunctionPrototype} to define the
 * arguments to a function.
 */

var ArgumentDef = /*#__PURE__*/function () {
  /**
   * Construct an argument defintion. The {@link In}, {@link Out}, and {@link InOut}
   * helper classes should be used to construct argument definitions as they are
   * semantically clearer and avoid the possibility of setting both `isInput` and
   * `isOutput` to `false`.
   * @param {Type} type The argument type
   * @param {boolean} isInput If true the argument provides data to the function
   * @param {boolean} isOutput If true the argument is poulated by the function
   */
  function ArgumentDef(type, isInput, isOutput) {
    _classCallCheck(this, ArgumentDef);

    this.type = type;
    this.isInput = isInput;
    this.isOutput = isOutput;
  }
  /**
   * Create a representation of the JavaScript value which can be passed to a
   * WebAssembly module instance. For value types this is typically the value
   * itself. For refrence types memory will be allocated in the instance, and
   * the data will be copied.
   * @param {T} value The value for which a WebAssembly value should be created
   * @param {MemoryManager} memoryManager A class which provides methods to
   *    manage the memory of a WebAssembly module.
   */


  _createClass(ArgumentDef, [{
    key: "marshall",
    value: function marshall(value, memoryManager) {
      if (this.type instanceof _ValueType__WEBPACK_IMPORTED_MODULE_1__["ValueType"]) {
        return value;
      } else if (this.isInput) {
        return this.type.marshall(value, memoryManager);
      } else {
        return this.type.alloc(memoryManager, value);
      }
    }
  }, {
    key: "unmarshall",
    value: function unmarshall(addressOrValue, memoryManager, value) {
      if (this.type instanceof _ValueType__WEBPACK_IMPORTED_MODULE_1__["ValueType"]) {
        return addressOrValue;
      }

      if (this.isOutput) {
        if (value == null) {
          throw new Error('Out put argument missing');
        }

        if (typeof addressOrValue !== 'number') {
          throw new Error('Expected address to be a number');
        }

        var result = this.type.unmarshall(addressOrValue, memoryManager, value);
        this.type.copy(value, result);
      } else {
        if (typeof addressOrValue !== 'number') {
          throw new Error('Expected address to be a number');
        }

        this.type.free(addressOrValue, memoryManager, value);
      }
    }
  }]);

  return ArgumentDef;
}();

/***/ }),

/***/ "./src/types/ArrayType.js":
/*!********************************!*\
  !*** ./src/types/ArrayType.js ***!
  \********************************/
/*! exports provided: ArrayType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrayType", function() { return ArrayType; });
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MemoryManager */ "./src/MemoryManager.js");
/* harmony import */ var _ReferenceType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReferenceType */ "./src/types/ReferenceType.js");
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Type */ "./src/types/Type.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var ArrayType = /*#__PURE__*/function (_ReferenceType) {
  _inherits(ArrayType, _ReferenceType);

  var _super = _createSuper(ArrayType);

  function ArrayType(type, length) {
    var _this;

    _classCallCheck(this, ArrayType);

    _this = _super.call(this);
    _this.type = type;
    _this.length = length;
    return _this;
  }

  _createClass(ArrayType, [{
    key: "alloc",
    value: function alloc(memoryManager, array) {
      if (this.length != null && array != null && this.length !== array.length) {
        throw new RangeError('Invalid array length');
      }

      var length = array != null ? array.length : this.length;

      if (length == null) {
        throw new RangeError('Unknown length');
      }

      return memoryManager.malloc(length * this.type.TypedArrayType.BYTES_PER_ELEMENT);
    }
  }, {
    key: "free",
    value: function free(address, memoryManager, array) {
      var _this2 = this;

      try {
        var length = array != null ? array.length : this.length;

        if (length == null) {
          throw new Error('Unknwon length for array');
        }

        if (this.type instanceof _ReferenceType__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"]) {
          var typedArray = new this.type.TypedArrayType(memoryManager.memory.buffer, address, length);
          typedArray.forEach(function (item) {
            return _this2.type.free(item, memoryManager);
          });
        }
      } finally {
        memoryManager.free(address);
      }
    }
  }, {
    key: "marshall",
    value: function marshall(array, memoryManager) {
      var _this3 = this;

      var address = this.alloc(memoryManager, array);
      var typedArray = new this.type.TypedArrayType(memoryManager.memory.buffer, address, array.length);

      if (this.type instanceof _ReferenceType__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"]) {
        array.forEach(function (item, i) {
          typedArray[i] = _this3.type.marshall(item, memoryManager);
        });
      } else {
        typedArray.set(array);
      }

      return address;
    }
  }, {
    key: "unmarshall",
    value: function unmarshall(address, memoryManager, array) {
      var _this4 = this;

      try {
        var length = array != null ? array.length : this.length;

        if (length == null) {
          throw new Error('Unknwon length for array');
        }

        var typedArray = new this.type.TypedArrayType(memoryManager.memory.buffer, address, length);
        return this.type instanceof _ReferenceType__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"] ? Array.from(typedArray, function (x) {
          return _this4.type.unmarshall(x, memoryManager);
        }) : Array.from(typedArray);
      } finally {
        memoryManager.free(address);
      }
    }
  }, {
    key: "copy",
    value: function copy(dest, source) {
      dest.splice.apply(dest, [0, dest.length].concat(_toConsumableArray(source)));
      return dest;
    }
  }]);

  return ArrayType;
}(_ReferenceType__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"]);

/***/ }),

/***/ "./src/types/Float32Type.js":
/*!**********************************!*\
  !*** ./src/types/Float32Type.js ***!
  \**********************************/
/*! exports provided: Float32Type */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32Type", function() { return Float32Type; });
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MemoryManager */ "./src/MemoryManager.js");
/* harmony import */ var _ValueType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ValueType */ "./src/types/ValueType.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Float32Type = /*#__PURE__*/function (_ValueType) {
  _inherits(Float32Type, _ValueType);

  var _super = _createSuper(Float32Type);

  function Float32Type() {
    _classCallCheck(this, Float32Type);

    return _super.call(this, Float32Array);
  }

  _createClass(Float32Type, [{
    key: "marshall",
    value: function marshall(value, memoryManager) {
      var address = this.alloc(memoryManager);
      memoryManager.dataView.setFloat32(address, value);
      return address;
    }
  }, {
    key: "unmarshall",
    value: function unmarshall(address, memoryManager) {
      try {
        return memoryManager.dataView.getFloat32(address);
      } finally {
        memoryManager.free(address);
      }
    }
  }]);

  return Float32Type;
}(_ValueType__WEBPACK_IMPORTED_MODULE_1__["ValueType"]);

/***/ }),

/***/ "./src/types/Float64Type.js":
/*!**********************************!*\
  !*** ./src/types/Float64Type.js ***!
  \**********************************/
/*! exports provided: Float64Type */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64Type", function() { return Float64Type; });
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MemoryManager */ "./src/MemoryManager.js");
/* harmony import */ var _ValueType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ValueType */ "./src/types/ValueType.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Float64Type = /*#__PURE__*/function (_ValueType) {
  _inherits(Float64Type, _ValueType);

  var _super = _createSuper(Float64Type);

  function Float64Type() {
    _classCallCheck(this, Float64Type);

    return _super.call(this, Float64Array);
  }

  _createClass(Float64Type, [{
    key: "marshall",
    value: function marshall(value, memoryManager) {
      var address = this.alloc(memoryManager);
      memoryManager.dataView.setFloat64(address, value);
      return address;
    }
  }, {
    key: "unmarshall",
    value: function unmarshall(address, memoryManager) {
      try {
        return memoryManager.dataView.getFloat64(address);
      } finally {
        memoryManager.free(address);
      }
    }
  }]);

  return Float64Type;
}(_ValueType__WEBPACK_IMPORTED_MODULE_1__["ValueType"]);

/***/ }),

/***/ "./src/types/FunctionPrototype.js":
/*!****************************************!*\
  !*** ./src/types/FunctionPrototype.js ***!
  \****************************************/
/*! exports provided: FunctionPrototype */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FunctionPrototype", function() { return FunctionPrototype; });
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MemoryManager */ "./src/MemoryManager.js");
/* harmony import */ var _ArgumentDef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ArgumentDef */ "./src/types/ArgumentDef.js");
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Type */ "./src/types/Type.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




var FunctionPrototype = /*#__PURE__*/function () {
  function FunctionPrototype(argDefs, returns) {
    _classCallCheck(this, FunctionPrototype);

    this.argDefs = argDefs;
    this.returns = returns;
  }

  _createClass(FunctionPrototype, [{
    key: "invoke",
    value: function invoke(memoryManager, func) {
      var _this = this;

      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      if (this.argDefs.length !== args.length) {
        throw new RangeError('Invalid number of arguments');
      }

      var marshalledArgs = args.map(function (arg, i) {
        return _this.argDefs[i].marshall(arg, memoryManager);
      });
      var result = func.apply(void 0, _toConsumableArray(marshalledArgs));
      args.forEach(function (arg, i) {
        return _this.argDefs[i].unmarshall(marshalledArgs[i], memoryManager, arg);
      });

      if (this.returns != null) {
        return this.returns.unmarshall(result, memoryManager);
      }
    }
  }]);

  return FunctionPrototype;
}();

/***/ }),

/***/ "./src/types/Int16Type.js":
/*!********************************!*\
  !*** ./src/types/Int16Type.js ***!
  \********************************/
/*! exports provided: Int16Type */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16Type", function() { return Int16Type; });
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MemoryManager */ "./src/MemoryManager.js");
/* harmony import */ var _ValueType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ValueType */ "./src/types/ValueType.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Int16Type = /*#__PURE__*/function (_ValueType) {
  _inherits(Int16Type, _ValueType);

  var _super = _createSuper(Int16Type);

  function Int16Type() {
    _classCallCheck(this, Int16Type);

    return _super.call(this, Int8Array);
  }

  _createClass(Int16Type, [{
    key: "marshall",
    value: function marshall(value, memoryManager) {
      var address = this.alloc(memoryManager);
      memoryManager.dataView.setInt16(address, value);
      return address;
    }
  }, {
    key: "unmarshall",
    value: function unmarshall(address, memoryManager) {
      try {
        return memoryManager.dataView.getInt16(address);
      } finally {
        memoryManager.free(address);
      }
    }
  }]);

  return Int16Type;
}(_ValueType__WEBPACK_IMPORTED_MODULE_1__["ValueType"]);

/***/ }),

/***/ "./src/types/Int32Type.js":
/*!********************************!*\
  !*** ./src/types/Int32Type.js ***!
  \********************************/
/*! exports provided: Int32Type */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32Type", function() { return Int32Type; });
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MemoryManager */ "./src/MemoryManager.js");
/* harmony import */ var _ValueType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ValueType */ "./src/types/ValueType.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Int32Type = /*#__PURE__*/function (_ValueType) {
  _inherits(Int32Type, _ValueType);

  var _super = _createSuper(Int32Type);

  function Int32Type() {
    _classCallCheck(this, Int32Type);

    return _super.call(this, Int32Array);
  }

  _createClass(Int32Type, [{
    key: "marshall",
    value: function marshall(value, memoryManager) {
      var address = this.alloc(memoryManager);
      memoryManager.dataView.setInt32(address, value);
      return address;
    }
  }, {
    key: "unmarshall",
    value: function unmarshall(address, memoryManager) {
      try {
        return memoryManager.dataView.getInt32(address);
      } finally {
        memoryManager.free(address);
      }
    }
  }]);

  return Int32Type;
}(_ValueType__WEBPACK_IMPORTED_MODULE_1__["ValueType"]);

/***/ }),

/***/ "./src/types/Int64Type.js":
/*!********************************!*\
  !*** ./src/types/Int64Type.js ***!
  \********************************/
/*! exports provided: Int64Type */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int64Type", function() { return Int64Type; });
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MemoryManager */ "./src/MemoryManager.js");
/* harmony import */ var _ValueType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ValueType */ "./src/types/ValueType.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Int64Type = /*#__PURE__*/function (_ValueType) {
  _inherits(Int64Type, _ValueType);

  var _super = _createSuper(Int64Type);

  function Int64Type() {
    _classCallCheck(this, Int64Type);

    // $FlowFixMe
    return _super.call(this, BigInt64Array);
  }

  _createClass(Int64Type, [{
    key: "marshall",
    value: function marshall(value, memoryManager) {
      var address = this.alloc(memoryManager);
      memoryManager.dataView.setBigInt64(address, value);
      return address;
    }
  }, {
    key: "unmarshall",
    value: function unmarshall(address, memoryManager) {
      try {
        return memoryManager.dataView.getBigInt64(address);
      } finally {
        memoryManager.free(address);
      }
    }
  }]);

  return Int64Type;
}(_ValueType__WEBPACK_IMPORTED_MODULE_1__["ValueType"]);

/***/ }),

/***/ "./src/types/Int8Type.js":
/*!*******************************!*\
  !*** ./src/types/Int8Type.js ***!
  \*******************************/
/*! exports provided: Int8Type */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8Type", function() { return Int8Type; });
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MemoryManager */ "./src/MemoryManager.js");
/* harmony import */ var _ValueType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ValueType */ "./src/types/ValueType.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Int8Type = /*#__PURE__*/function (_ValueType) {
  _inherits(Int8Type, _ValueType);

  var _super = _createSuper(Int8Type);

  function Int8Type() {
    _classCallCheck(this, Int8Type);

    return _super.call(this, Int8Array);
  }

  _createClass(Int8Type, [{
    key: "marshall",
    value: function marshall(value, memoryManager) {
      var address = this.alloc(memoryManager);
      memoryManager.dataView.setInt8(address, value);
      return address;
    }
  }, {
    key: "unmarshall",
    value: function unmarshall(address, memoryManager) {
      try {
        return memoryManager.dataView.getInt8(address);
      } finally {
        memoryManager.free(address);
      }
    }
  }]);

  return Int8Type;
}(_ValueType__WEBPACK_IMPORTED_MODULE_1__["ValueType"]);

/***/ }),

/***/ "./src/types/Pointer.js":
/*!******************************!*\
  !*** ./src/types/Pointer.js ***!
  \******************************/
/*! exports provided: Pointer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Pointer", function() { return Pointer; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Pointer = function Pointer(contents) {
  _classCallCheck(this, Pointer);

  this.contents = contents;
};

/***/ }),

/***/ "./src/types/PointerType.js":
/*!**********************************!*\
  !*** ./src/types/PointerType.js ***!
  \**********************************/
/*! exports provided: PointerType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointerType", function() { return PointerType; });
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MemoryManager */ "./src/MemoryManager.js");
/* harmony import */ var _Pointer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Pointer */ "./src/types/Pointer.js");
/* harmony import */ var _ReferenceType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReferenceType */ "./src/types/ReferenceType.js");
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Type */ "./src/types/Type.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





var PointerType = /*#__PURE__*/function (_ReferenceType) {
  _inherits(PointerType, _ReferenceType);

  var _super = _createSuper(PointerType);

  function PointerType(type) {
    var _this;

    _classCallCheck(this, PointerType);

    _this = _super.call(this);
    _this.type = type;
    return _this;
  }

  _createClass(PointerType, [{
    key: "free",
    value: function free(address, memoryManager) {
      try {
        var marshalledAddress = memoryManager.dataView.getUint32(address);
        this.type.free(marshalledAddress, memoryManager);
      } finally {
        memoryManager.free(address);
      }
    }
  }, {
    key: "alloc",
    value: function alloc(memoryManager) {
      var address = memoryManager.malloc(Uint32Array.BYTES_PER_ELEMENT);
      return address;
    }
  }, {
    key: "marshall",
    value: function marshall(value, memoryManager) {
      var address = this.alloc(memoryManager);
      var marshalledAddress = this.type.marshall(value.contents, memoryManager);
      memoryManager.dataView.setUint32(address, marshalledAddress);
      return address;
    }
  }, {
    key: "unmarshall",
    value: function unmarshall(address, memoryManager) {
      try {
        var marshalledAddress = memoryManager.dataView.getUint32(address);
        return new _Pointer__WEBPACK_IMPORTED_MODULE_1__["Pointer"](this.type.unmarshall(marshalledAddress, memoryManager));
      } finally {
        memoryManager.free(address);
      }
    }
  }, {
    key: "copy",
    value: function copy(dest, source) {
      dest.contents = source.contents;
      return dest;
    }
  }]);

  return PointerType;
}(_ReferenceType__WEBPACK_IMPORTED_MODULE_2__["ReferenceType"]);

/***/ }),

/***/ "./src/types/ReferenceType.js":
/*!************************************!*\
  !*** ./src/types/ReferenceType.js ***!
  \************************************/
/*! exports provided: ReferenceType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReferenceType", function() { return ReferenceType; });
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Type */ "./src/types/Type.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var ReferenceType = /*#__PURE__*/function (_Type) {
  _inherits(ReferenceType, _Type);

  var _super = _createSuper(ReferenceType);

  function ReferenceType() {
    _classCallCheck(this, ReferenceType);

    return _super.call(this, Uint32Array);
  }

  return ReferenceType;
}(_Type__WEBPACK_IMPORTED_MODULE_0__["Type"]);

/***/ }),

/***/ "./src/types/StringType.js":
/*!*********************************!*\
  !*** ./src/types/StringType.js ***!
  \*********************************/
/*! exports provided: StringType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StringType", function() { return StringType; });
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MemoryManager */ "./src/MemoryManager.js");
/* harmony import */ var _ReferenceType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReferenceType */ "./src/types/ReferenceType.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var StringType = /*#__PURE__*/function (_ReferenceType) {
  _inherits(StringType, _ReferenceType);

  var _super = _createSuper(StringType);

  function StringType() {
    _classCallCheck(this, StringType);

    return _super.apply(this, arguments);
  }

  _createClass(StringType, [{
    key: "free",
    value: function free(address, memoryManager) {
      memoryManager.free(address);
    } // Convert a JavaScript string to a pointer to multi byte character array

  }, {
    key: "marshall",
    value: function marshall(string, memoryManager) {
      // Encode the string in utf-8.
      var encoder = new TextEncoder();
      var encodedString = encoder.encode(string); // Copy the string into memory allocated in the WebAssembly

      var address = memoryManager.malloc(encodedString.byteLength + 1);
      var buf = new Uint8Array(memoryManager.memory.buffer, address, encodedString.byteLength + 1);
      buf.set(encodedString);
      return address;
    } // Convert a null terminated pointer from the wasm module to JavaScript string.

  }, {
    key: "unmarshall",
    value: function unmarshall(address, memoryManager) {
      try {
        // Find the number of bytes before the null termination character.
        var buf = new Uint8Array(memoryManager.memory.buffer, address);
        var length = 0;

        while (buf[length] !== 0) {
          ++length;
        } // Decode the string


        var array = new Uint8Array(memoryManager.memory.buffer, address, length);
        var decoder = new TextDecoder();
        var string = decoder.decode(array);
        return string;
      } finally {
        // Free the memory
        memoryManager.free(address);
      }
    }
  }]);

  return StringType;
}(_ReferenceType__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"]);

/***/ }),

/***/ "./src/types/Type.js":
/*!***************************!*\
  !*** ./src/types/Type.js ***!
  \***************************/
/*! exports provided: Type */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Type", function() { return Type; });
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MemoryManager */ "./src/MemoryManager.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


var Type = /*#__PURE__*/function () {
  function Type(typedArrayType) {
    _classCallCheck(this, Type);

    this.TypedArrayType = typedArrayType;
  }

  _createClass(Type, [{
    key: "alloc",
    value: function alloc(memoryManager, array) {
      throw new Error('Not Implemented');
    }
  }, {
    key: "free",
    value: function free(address, memoryManager, value) {
      throw new Error('Not Implemented');
    }
  }, {
    key: "marshall",
    value: function marshall(value, memoryManager) {
      throw new Error('Not Implemented');
    }
  }, {
    key: "unmarshall",
    value: function unmarshall(address, memoryManager, value) {
      throw new Error('Not Implemented');
    }
  }, {
    key: "copy",
    value: function copy(dest, source) {
      throw new Error('Not Implemented');
    }
  }]);

  return Type;
}();

/***/ }),

/***/ "./src/types/Uint16Type.js":
/*!*********************************!*\
  !*** ./src/types/Uint16Type.js ***!
  \*********************************/
/*! exports provided: Uint16Type */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16Type", function() { return Uint16Type; });
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MemoryManager */ "./src/MemoryManager.js");
/* harmony import */ var _ValueType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ValueType */ "./src/types/ValueType.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Uint16Type = /*#__PURE__*/function (_ValueType) {
  _inherits(Uint16Type, _ValueType);

  var _super = _createSuper(Uint16Type);

  function Uint16Type() {
    _classCallCheck(this, Uint16Type);

    return _super.call(this, Uint16Array);
  }

  _createClass(Uint16Type, [{
    key: "marshall",
    value: function marshall(value, memoryManager) {
      var address = this.alloc(memoryManager);
      memoryManager.dataView.setUint16(address, value);
      return address;
    }
  }, {
    key: "unmarshall",
    value: function unmarshall(address, memoryManager) {
      try {
        return memoryManager.dataView.getUint16(address);
      } finally {
        memoryManager.free(address);
      }
    }
  }]);

  return Uint16Type;
}(_ValueType__WEBPACK_IMPORTED_MODULE_1__["ValueType"]);

/***/ }),

/***/ "./src/types/Uint32Type.js":
/*!*********************************!*\
  !*** ./src/types/Uint32Type.js ***!
  \*********************************/
/*! exports provided: Uint32Type */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32Type", function() { return Uint32Type; });
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MemoryManager */ "./src/MemoryManager.js");
/* harmony import */ var _ValueType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ValueType */ "./src/types/ValueType.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Uint32Type = /*#__PURE__*/function (_ValueType) {
  _inherits(Uint32Type, _ValueType);

  var _super = _createSuper(Uint32Type);

  function Uint32Type() {
    _classCallCheck(this, Uint32Type);

    return _super.call(this, Uint32Array);
  }

  _createClass(Uint32Type, [{
    key: "marshall",
    value: function marshall(value, memoryManager) {
      var address = this.alloc(memoryManager);
      memoryManager.dataView.setUint32(address, value);
      return address;
    }
  }, {
    key: "unmarshall",
    value: function unmarshall(address, memoryManager) {
      try {
        return memoryManager.dataView.getUint32(address);
      } finally {
        memoryManager.free(address);
      }
    }
  }]);

  return Uint32Type;
}(_ValueType__WEBPACK_IMPORTED_MODULE_1__["ValueType"]);

/***/ }),

/***/ "./src/types/Uint64Type.js":
/*!*********************************!*\
  !*** ./src/types/Uint64Type.js ***!
  \*********************************/
/*! exports provided: Uint64Type */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint64Type", function() { return Uint64Type; });
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MemoryManager */ "./src/MemoryManager.js");
/* harmony import */ var _ValueType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ValueType */ "./src/types/ValueType.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Uint64Type = /*#__PURE__*/function (_ValueType) {
  _inherits(Uint64Type, _ValueType);

  var _super = _createSuper(Uint64Type);

  function Uint64Type() {
    _classCallCheck(this, Uint64Type);

    // $FlowFixMe
    return _super.call(this, BigUint64Array);
  }

  _createClass(Uint64Type, [{
    key: "marshall",
    value: function marshall(value, memoryManager) {
      var address = this.alloc(memoryManager);
      memoryManager.dataView.setBigUint64(address, value);
      return address;
    }
  }, {
    key: "unmarshall",
    value: function unmarshall(address, memoryManager) {
      try {
        return memoryManager.dataView.getBigUint64(address);
      } finally {
        memoryManager.free(address);
      }
    }
  }]);

  return Uint64Type;
}(_ValueType__WEBPACK_IMPORTED_MODULE_1__["ValueType"]);

/***/ }),

/***/ "./src/types/Uint8Type.js":
/*!********************************!*\
  !*** ./src/types/Uint8Type.js ***!
  \********************************/
/*! exports provided: Uint8Type */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8Type", function() { return Uint8Type; });
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MemoryManager */ "./src/MemoryManager.js");
/* harmony import */ var _ValueType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ValueType */ "./src/types/ValueType.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Uint8Type = /*#__PURE__*/function (_ValueType) {
  _inherits(Uint8Type, _ValueType);

  var _super = _createSuper(Uint8Type);

  function Uint8Type() {
    _classCallCheck(this, Uint8Type);

    return _super.call(this, Uint8Array);
  }

  _createClass(Uint8Type, [{
    key: "marshall",
    value: function marshall(value, memoryManager) {
      var address = this.alloc(memoryManager);
      memoryManager.dataView.setUint8(address, value);
      return address;
    }
  }, {
    key: "unmarshall",
    value: function unmarshall(address, memoryManager) {
      try {
        return memoryManager.dataView.getUint8(address);
      } finally {
        memoryManager.free(address);
      }
    }
  }]);

  return Uint8Type;
}(_ValueType__WEBPACK_IMPORTED_MODULE_1__["ValueType"]);

/***/ }),

/***/ "./src/types/ValueType.js":
/*!********************************!*\
  !*** ./src/types/ValueType.js ***!
  \********************************/
/*! exports provided: ValueType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ValueType", function() { return ValueType; });
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MemoryManager */ "./src/MemoryManager.js");
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Type */ "./src/types/Type.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var ValueType = /*#__PURE__*/function (_Type) {
  _inherits(ValueType, _Type);

  var _super = _createSuper(ValueType);

  function ValueType() {
    _classCallCheck(this, ValueType);

    return _super.apply(this, arguments);
  }

  _createClass(ValueType, [{
    key: "alloc",
    value: function alloc(memoryManager) {
      return memoryManager.malloc(this.TypedArrayType.BYTES_PER_ELEMENT);
    }
  }, {
    key: "free",
    value: function free(address, memoryManager) {
      memoryManager.free(address);
    }
  }]);

  return ValueType;
}(_Type__WEBPACK_IMPORTED_MODULE_1__["Type"]);

/***/ }),

/***/ "./src/types/arguments.js":
/*!********************************!*\
  !*** ./src/types/arguments.js ***!
  \********************************/
/*! exports provided: In, Out, InOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "In", function() { return In; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Out", function() { return Out; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InOut", function() { return InOut; });
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Type */ "./src/types/Type.js");
/* harmony import */ var _ArgumentDef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ArgumentDef */ "./src/types/ArgumentDef.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var In = /*#__PURE__*/function (_ArgumentDef) {
  _inherits(In, _ArgumentDef);

  var _super = _createSuper(In);

  function In(type) {
    _classCallCheck(this, In);

    return _super.call(this, type, true, false);
  }

  return In;
}(_ArgumentDef__WEBPACK_IMPORTED_MODULE_1__["ArgumentDef"]);
var Out = /*#__PURE__*/function (_ArgumentDef2) {
  _inherits(Out, _ArgumentDef2);

  var _super2 = _createSuper(Out);

  function Out(type) {
    _classCallCheck(this, Out);

    return _super2.call(this, type, false, true);
  }

  return Out;
}(_ArgumentDef__WEBPACK_IMPORTED_MODULE_1__["ArgumentDef"]);
var InOut = /*#__PURE__*/function (_ArgumentDef3) {
  _inherits(InOut, _ArgumentDef3);

  var _super3 = _createSuper(InOut);

  function InOut(type) {
    _classCallCheck(this, InOut);

    return _super3.call(this, type, true, true);
  }

  return InOut;
}(_ArgumentDef__WEBPACK_IMPORTED_MODULE_1__["ArgumentDef"]);

/***/ }),

/***/ "./src/types/index.js":
/*!****************************!*\
  !*** ./src/types/index.js ***!
  \****************************/
/*! exports provided: Type, ValueType, Int8Type, Int16Type, Int32Type, Int64Type, Uint8Type, Uint16Type, Uint32Type, Uint64Type, Float32Type, Float64Type, ReferenceType, StringType, Pointer, PointerType, ArrayType, ArgumentDef, In, Out, InOut, FunctionPrototype */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Type */ "./src/types/Type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Type", function() { return _Type__WEBPACK_IMPORTED_MODULE_0__["Type"]; });

/* harmony import */ var _ValueType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ValueType */ "./src/types/ValueType.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ValueType", function() { return _ValueType__WEBPACK_IMPORTED_MODULE_1__["ValueType"]; });

/* harmony import */ var _Int8Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Int8Type */ "./src/types/Int8Type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int8Type", function() { return _Int8Type__WEBPACK_IMPORTED_MODULE_2__["Int8Type"]; });

/* harmony import */ var _Int16Type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Int16Type */ "./src/types/Int16Type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int16Type", function() { return _Int16Type__WEBPACK_IMPORTED_MODULE_3__["Int16Type"]; });

/* harmony import */ var _Int32Type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Int32Type */ "./src/types/Int32Type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int32Type", function() { return _Int32Type__WEBPACK_IMPORTED_MODULE_4__["Int32Type"]; });

/* harmony import */ var _Int64Type__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Int64Type */ "./src/types/Int64Type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int64Type", function() { return _Int64Type__WEBPACK_IMPORTED_MODULE_5__["Int64Type"]; });

/* harmony import */ var _Uint8Type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Uint8Type */ "./src/types/Uint8Type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint8Type", function() { return _Uint8Type__WEBPACK_IMPORTED_MODULE_6__["Uint8Type"]; });

/* harmony import */ var _Uint16Type__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Uint16Type */ "./src/types/Uint16Type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint16Type", function() { return _Uint16Type__WEBPACK_IMPORTED_MODULE_7__["Uint16Type"]; });

/* harmony import */ var _Uint32Type__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Uint32Type */ "./src/types/Uint32Type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint32Type", function() { return _Uint32Type__WEBPACK_IMPORTED_MODULE_8__["Uint32Type"]; });

/* harmony import */ var _Uint64Type__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Uint64Type */ "./src/types/Uint64Type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint64Type", function() { return _Uint64Type__WEBPACK_IMPORTED_MODULE_9__["Uint64Type"]; });

/* harmony import */ var _Float32Type__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Float32Type */ "./src/types/Float32Type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float32Type", function() { return _Float32Type__WEBPACK_IMPORTED_MODULE_10__["Float32Type"]; });

/* harmony import */ var _Float64Type__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Float64Type */ "./src/types/Float64Type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float64Type", function() { return _Float64Type__WEBPACK_IMPORTED_MODULE_11__["Float64Type"]; });

/* harmony import */ var _ReferenceType__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ReferenceType */ "./src/types/ReferenceType.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ReferenceType", function() { return _ReferenceType__WEBPACK_IMPORTED_MODULE_12__["ReferenceType"]; });

/* harmony import */ var _StringType__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./StringType */ "./src/types/StringType.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StringType", function() { return _StringType__WEBPACK_IMPORTED_MODULE_13__["StringType"]; });

/* harmony import */ var _Pointer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Pointer */ "./src/types/Pointer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Pointer", function() { return _Pointer__WEBPACK_IMPORTED_MODULE_14__["Pointer"]; });

/* harmony import */ var _PointerType__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./PointerType */ "./src/types/PointerType.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointerType", function() { return _PointerType__WEBPACK_IMPORTED_MODULE_15__["PointerType"]; });

/* harmony import */ var _ArrayType__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./ArrayType */ "./src/types/ArrayType.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ArrayType", function() { return _ArrayType__WEBPACK_IMPORTED_MODULE_16__["ArrayType"]; });

/* harmony import */ var _ArgumentDef__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./ArgumentDef */ "./src/types/ArgumentDef.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ArgumentDef", function() { return _ArgumentDef__WEBPACK_IMPORTED_MODULE_17__["ArgumentDef"]; });

/* harmony import */ var _arguments__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./arguments */ "./src/types/arguments.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "In", function() { return _arguments__WEBPACK_IMPORTED_MODULE_18__["In"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Out", function() { return _arguments__WEBPACK_IMPORTED_MODULE_18__["Out"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InOut", function() { return _arguments__WEBPACK_IMPORTED_MODULE_18__["InOut"]; });

/* harmony import */ var _FunctionPrototype__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./FunctionPrototype */ "./src/types/FunctionPrototype.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FunctionPrototype", function() { return _FunctionPrototype__WEBPACK_IMPORTED_MODULE_19__["FunctionPrototype"]; });






















/***/ }),

/***/ "./src/wasi.js":
/*!*********************!*\
  !*** ./src/wasi.js ***!
  \*********************/
/*! exports provided: Wasi */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Wasi", function() { return Wasi; });
/* harmony import */ var _MemoryManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MemoryManager */ "./src/MemoryManager.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./src/constants.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




function drainWriter(write, prev, current) {
  var text = prev + current;

  while (text.includes('\n')) {
    var _text$split = text.split('\n', 2),
        _text$split2 = _slicedToArray(_text$split, 2),
        _line = _text$split2[0],
        rest = _text$split2[1];

    write(_line);
    text = rest;
  }

  return text;
} // An implementation of WASI which supports the minimum
// required to use multi byte characters.


var Wasi = /*#__PURE__*/function () {
  function Wasi(env) {
    _classCallCheck(this, Wasi);

    this.env = env;
    this.instance = null;
    this.memoryManager = null;
    this.stdoutText = '';
    this.stderrText = '';
  } // Initialise the instance from the WebAssembly.


  _createClass(Wasi, [{
    key: "init",
    value: function init(instance) {
      this.instance = instance; // $FlowFixMe

      this.memoryManager = new _MemoryManager__WEBPACK_IMPORTED_MODULE_0__["MemoryManager"](instance.exports.memory, instance.exports.malloc, instance.exports.free);
    } // Get the environment variables.

  }, {
    key: "environ_get",
    value: function environ_get(environ, environBuf) {
      var _this = this;

      var encoder = new TextEncoder();
      Object.entries(this.env).map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[0],
            value = _ref2[1];

        return "".concat(key, "=").concat(value);
      }).forEach(function (envVar) {
        _this.memoryManager.dataView.setUint32(environ, environBuf, true);

        environ += 4;
        var bytes = encoder.encode(envVar);
        var buf = new Uint8Array(_this.memoryManager.memory.buffer, environBuf, bytes.length + 1);
        environBuf += buf.byteLength;
      });
      return _constants__WEBPACK_IMPORTED_MODULE_1__["WASI"].ESUCCESS;
    } // Get the size required to store the environment variables.

  }, {
    key: "environ_sizes_get",
    value: function environ_sizes_get(environCount, environBufSize) {
      var encoder = new TextEncoder();
      var envVars = Object.entries(this.env).map(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            key = _ref4[0],
            value = _ref4[1];

        return "".concat(key, "=").concat(value);
      });
      var size = envVars.reduce(function (acc, envVar) {
        return acc + encoder.encode(envVar).byteLength + 1;
      }, 0);
      this.memoryManager.dataView.setUint32(environCount, envVars.length, true);
      this.memoryManager.dataView.setUint32(environBufSize, size, true);
      return _constants__WEBPACK_IMPORTED_MODULE_1__["WASI"].ESUCCESS;
    } // This gets called on exit to stop the running program.
    // We don't have anything to stop!

  }, {
    key: "proc_exit",
    value: function proc_exit(rval) {
      return _constants__WEBPACK_IMPORTED_MODULE_1__["WASI"].ESUCCESS;
    }
  }, {
    key: "fd_close",
    value: function fd_close(fd) {
      return _constants__WEBPACK_IMPORTED_MODULE_1__["WASI"].ESUCCESS;
    }
  }, {
    key: "fd_seek",
    value: function fd_seek(fd, offset_low, offset_high, whence, newOffset) {
      return _constants__WEBPACK_IMPORTED_MODULE_1__["WASI"].ESUCCESS;
    }
  }, {
    key: "fd_write",
    value: function fd_write(fd, iovs, iovsLen, nwritten) {
      var _this2 = this;

      if (!(fd === 1 | fd === 2)) {
        return _constants__WEBPACK_IMPORTED_MODULE_1__["WASI"].ERRNO.BADF;
      }

      var buffers = Array.from({
        length: iovsLen
      }, function (_, i) {
        var ptr = iovs + i * 8;

        var buf = _this2.memeoryManager.dataView.getUint32(ptr, true);

        var bufLen = _this2.memeoryManager.dataView.getUint32(ptr + 4, true);

        return new Uint8Array(_this2.memoryManager.memory.buffer, buf, bufLen);
      });
      var textDecoder = new TextDecoder();
      var written = 0;
      var text = '';
      buffers.forEach(function (buf) {
        text += textDecoder.decode(buf);
        written += buf.byteLength;
      });
      this.memeoryManager.dataView.setUint32(nwritten, written, true);

      if (fd === _constants__WEBPACK_IMPORTED_MODULE_1__["STDOUT"]) {
        this.stdoutText = drainWriter(console.log, this.stdoutText, text);
      } else if (fd === _constants__WEBPACK_IMPORTED_MODULE_1__["STDERR"]) {
        this.stderrText = drainWriter(console.error, this.stderrText, text);
      }

      return _constants__WEBPACK_IMPORTED_MODULE_1__["WASI"].ESUCCESS;
    }
  }, {
    key: "fd_fdstat_get",
    value: function fd_fdstat_get(fd, stat) {
      if (!(fd === 1 | fd === 2)) {
        return _constants__WEBPACK_IMPORTED_MODULE_1__["WASI"].ERRNO.BADF;
      }

      if (this.memoryManager == null || this.memoryManager.dataView == undefined) {
        throw new Error('No memory');
      }

      this.memoryManager.dataView.setUint8(stat + 0, _constants__WEBPACK_IMPORTED_MODULE_1__["WASI"].FILETYPE.CHARACTER_DEVICE);
      this.memoryManager.dataView.setUint32(stat + 2, _constants__WEBPACK_IMPORTED_MODULE_1__["WASI"].FDFLAGS.APPEND, true);
      this.memoryManager.dataView.setBigUint64(stat + 8, _constants__WEBPACK_IMPORTED_MODULE_1__["WASI"].RIGHTS.FD_WRITE, true);
      this.memoryManager.dataView.setBigUint64(stat + 16, _constants__WEBPACK_IMPORTED_MODULE_1__["WASI"].RIGHTS.FD_WRITE, true);
      return _constants__WEBPACK_IMPORTED_MODULE_1__["WASI"].ESUCCESS;
    }
  }]);

  return Wasi;
}();

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./src/index.js */"./src/index.js");


/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9XYXNpTWFyc2hhbGxpbmcvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL1dhc2lNYXJzaGFsbGluZy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9XYXNpTWFyc2hhbGxpbmcvLi9ub2RlX21vZHVsZXMvZmxvdy1iaW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vV2FzaU1hcnNoYWxsaW5nLy4vbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9XYXNpTWFyc2hhbGxpbmcvLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovL1dhc2lNYXJzaGFsbGluZy8uL3NyYy9NZW1vcnlNYW5hZ2VyLmpzIiwid2VicGFjazovL1dhc2lNYXJzaGFsbGluZy8uL3NyYy9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vV2FzaU1hcnNoYWxsaW5nLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovL1dhc2lNYXJzaGFsbGluZy8uL3NyYy90eXBlcy9Bcmd1bWVudERlZi5qcyIsIndlYnBhY2s6Ly9XYXNpTWFyc2hhbGxpbmcvLi9zcmMvdHlwZXMvQXJyYXlUeXBlLmpzIiwid2VicGFjazovL1dhc2lNYXJzaGFsbGluZy8uL3NyYy90eXBlcy9GbG9hdDMyVHlwZS5qcyIsIndlYnBhY2s6Ly9XYXNpTWFyc2hhbGxpbmcvLi9zcmMvdHlwZXMvRmxvYXQ2NFR5cGUuanMiLCJ3ZWJwYWNrOi8vV2FzaU1hcnNoYWxsaW5nLy4vc3JjL3R5cGVzL0Z1bmN0aW9uUHJvdG90eXBlLmpzIiwid2VicGFjazovL1dhc2lNYXJzaGFsbGluZy8uL3NyYy90eXBlcy9JbnQxNlR5cGUuanMiLCJ3ZWJwYWNrOi8vV2FzaU1hcnNoYWxsaW5nLy4vc3JjL3R5cGVzL0ludDMyVHlwZS5qcyIsIndlYnBhY2s6Ly9XYXNpTWFyc2hhbGxpbmcvLi9zcmMvdHlwZXMvSW50NjRUeXBlLmpzIiwid2VicGFjazovL1dhc2lNYXJzaGFsbGluZy8uL3NyYy90eXBlcy9JbnQ4VHlwZS5qcyIsIndlYnBhY2s6Ly9XYXNpTWFyc2hhbGxpbmcvLi9zcmMvdHlwZXMvUG9pbnRlci5qcyIsIndlYnBhY2s6Ly9XYXNpTWFyc2hhbGxpbmcvLi9zcmMvdHlwZXMvUG9pbnRlclR5cGUuanMiLCJ3ZWJwYWNrOi8vV2FzaU1hcnNoYWxsaW5nLy4vc3JjL3R5cGVzL1JlZmVyZW5jZVR5cGUuanMiLCJ3ZWJwYWNrOi8vV2FzaU1hcnNoYWxsaW5nLy4vc3JjL3R5cGVzL1N0cmluZ1R5cGUuanMiLCJ3ZWJwYWNrOi8vV2FzaU1hcnNoYWxsaW5nLy4vc3JjL3R5cGVzL1R5cGUuanMiLCJ3ZWJwYWNrOi8vV2FzaU1hcnNoYWxsaW5nLy4vc3JjL3R5cGVzL1VpbnQxNlR5cGUuanMiLCJ3ZWJwYWNrOi8vV2FzaU1hcnNoYWxsaW5nLy4vc3JjL3R5cGVzL1VpbnQzMlR5cGUuanMiLCJ3ZWJwYWNrOi8vV2FzaU1hcnNoYWxsaW5nLy4vc3JjL3R5cGVzL1VpbnQ2NFR5cGUuanMiLCJ3ZWJwYWNrOi8vV2FzaU1hcnNoYWxsaW5nLy4vc3JjL3R5cGVzL1VpbnQ4VHlwZS5qcyIsIndlYnBhY2s6Ly9XYXNpTWFyc2hhbGxpbmcvLi9zcmMvdHlwZXMvVmFsdWVUeXBlLmpzIiwid2VicGFjazovL1dhc2lNYXJzaGFsbGluZy8uL3NyYy90eXBlcy9hcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vV2FzaU1hcnNoYWxsaW5nLy4vc3JjL3R5cGVzL2luZGV4LmpzIiwid2VicGFjazovL1dhc2lNYXJzaGFsbGluZy8uL3NyYy93YXNpLmpzIl0sIm5hbWVzIjpbIk1lbW9yeU1hbmFnZXIiLCJtZW1vcnkiLCJtYWxsb2MiLCJmcmVlIiwiZGF0YVZpZXciLCJEYXRhVmlldyIsImJ1ZmZlciIsIldBU0kiLCJFU1VDQ0VTUyIsIkVSUk5PIiwiQUNDRVMiLCJBRERSSU5VU0UiLCJBRERSTk9UQVZBSUwiLCJBRk5PU1VQUE9SVCIsIkFHQUlOIiwiQUxSRUFEWSIsIkJBREYiLCJCQURNU0ciLCJCVVNZIiwiQ0FOQ0VMRUQiLCJDSElMRCIsIkNPTk5BQk9SVEVEIiwiQ09OTlJFRlVTRUQiLCJDT05OUkVTRVQiLCJERUFETEsiLCJERVNUQUREUlJFUSIsIkRPTSIsIkRRVU9UIiwiRVhJU1QiLCJGQVVMVCIsIkZCSUciLCJIT1NUVU5SRUFDSCIsIklEUk0iLCJJTFNFUSIsIklOUFJPR1JFU1MiLCJJTlRSIiwiSU5WQUwiLCJJTyIsIklTQ09OTiIsIklTRElSIiwiTE9PUCIsIk1GSUxFIiwiTUxJTksiLCJNU0dTSVpFIiwiTVVMVElIT1AiLCJOQU1FVE9PTE9ORyIsIk5FVERPV04iLCJORVRSRVNFVCIsIk5FVFVOUkVBQ0giLCJORklMRSIsIk5PQlVGUyIsIk5PREVWIiwiTk9FTlQiLCJOT0VYRUMiLCJOT0xDSyIsIk5PTElOSyIsIk5PTUVNIiwiTk9NU0ciLCJOT1BST1RPT1BUIiwiTk9TUEMiLCJOT1NZUyIsIk5PVENPTk4iLCJOT1RESVIiLCJOT1RFTVBUWSIsIk5PVFJFQ09WRVJBQkxFIiwiTk9UU09DSyIsIk5PVFNVUCIsIk5PVFRZIiwiTlhJTyIsIk9WRVJGTE9XIiwiT1dORVJERUFEIiwiUEVSTSIsIlBJUEUiLCJQUk9UTyIsIlBST1RPTk9TVVBQT1JUIiwiUFJPVE9UWVBFIiwiUkFOR0UiLCJST0ZTIiwiU1BJUEUiLCJTUkNIIiwiU1RBTEUiLCJUSU1FRE9VVCIsIlRYVEJTWSIsIlhERVYiLCJOT1RDQVBBQkxFIiwiRklMRVRZUEUiLCJVTktOT1dOIiwiQkxPQ0tfREVWSUNFIiwiQ0hBUkFDVEVSX0RFVklDRSIsIkRJUkVDVE9SWSIsIlJFR1VMQVJfRklMRSIsIlNPQ0tFVF9ER1JBTSIsIlNPQ0tFVF9TVFJFQU0iLCJTWU1CT0xJQ19MSU5LIiwiRkRGTEFHUyIsIkFQUEVORCIsIkRTWU5DIiwiTk9OQkxPQ0siLCJSU1lOQyIsIlNZTkMiLCJSSUdIVFMiLCJGRCIsIkRBVEFTWU5DIiwiUkVBRCIsIlNFRUsiLCJGRFNUQVRfU0VUX0ZMQUdTIiwiVEVMTCIsIldSSVRFIiwiQURWSVNFIiwiQUxMT0NBVEUiLCJSRUFERElSIiwiRklMRVNUQVRfR0VUIiwiRklMRVNUQVRfU0VUX1NJWkUiLCJGSUxFU1RBVF9TRVRfVElNRVMiLCJQQVRIIiwiQ1JFQVRFX0RJUkVDVE9SWSIsIkNSRUFURV9GSUxFIiwiTElOS19TT1VSQ0UiLCJMSU5LX1RBUkdFVCIsIk9QRU4iLCJSRUFETElOSyIsIlJFTkFNRV9TT1VSQ0UiLCJSRU5BTUVfVEFSR0VUIiwiU1lNTElOSyIsIlJFTU9WRV9ESVJFQ1RPUlkiLCJVTkxJTktfRklMRSIsIlBPTExfRkRfUkVBRFdSSVRFIiwiU09DS19TSFVURE9XTiIsIkFEVklDRSIsIk5PUk1BTCIsIlNFUVVFTlRJQUwiLCJSQU5ET00iLCJXSUxMTkVFRCIsIkRPTlRORUVEIiwiTk9SRVVTRSIsIlNURE9VVCIsIlNUREVSUiIsIkFyZ3VtZW50RGVmIiwidHlwZSIsImlzSW5wdXQiLCJpc091dHB1dCIsInZhbHVlIiwibWVtb3J5TWFuYWdlciIsIlZhbHVlVHlwZSIsIm1hcnNoYWxsIiwiYWxsb2MiLCJhZGRyZXNzT3JWYWx1ZSIsIkVycm9yIiwicmVzdWx0IiwidW5tYXJzaGFsbCIsImNvcHkiLCJBcnJheVR5cGUiLCJsZW5ndGgiLCJhcnJheSIsIlJhbmdlRXJyb3IiLCJUeXBlZEFycmF5VHlwZSIsIkJZVEVTX1BFUl9FTEVNRU5UIiwiYWRkcmVzcyIsIlJlZmVyZW5jZVR5cGUiLCJ0eXBlZEFycmF5IiwiZm9yRWFjaCIsIml0ZW0iLCJpIiwic2V0IiwiQXJyYXkiLCJmcm9tIiwieCIsImRlc3QiLCJzb3VyY2UiLCJzcGxpY2UiLCJGbG9hdDMyVHlwZSIsIkZsb2F0MzJBcnJheSIsInNldEZsb2F0MzIiLCJnZXRGbG9hdDMyIiwiRmxvYXQ2NFR5cGUiLCJGbG9hdDY0QXJyYXkiLCJzZXRGbG9hdDY0IiwiZ2V0RmxvYXQ2NCIsIkZ1bmN0aW9uUHJvdG90eXBlIiwiYXJnRGVmcyIsInJldHVybnMiLCJmdW5jIiwiYXJncyIsIm1hcnNoYWxsZWRBcmdzIiwibWFwIiwiYXJnIiwiSW50MTZUeXBlIiwiSW50OEFycmF5Iiwic2V0SW50MTYiLCJnZXRJbnQxNiIsIkludDMyVHlwZSIsIkludDMyQXJyYXkiLCJzZXRJbnQzMiIsImdldEludDMyIiwiSW50NjRUeXBlIiwiQmlnSW50NjRBcnJheSIsInNldEJpZ0ludDY0IiwiZ2V0QmlnSW50NjQiLCJJbnQ4VHlwZSIsInNldEludDgiLCJnZXRJbnQ4IiwiUG9pbnRlciIsImNvbnRlbnRzIiwiUG9pbnRlclR5cGUiLCJtYXJzaGFsbGVkQWRkcmVzcyIsImdldFVpbnQzMiIsIlVpbnQzMkFycmF5Iiwic2V0VWludDMyIiwiVHlwZSIsIlN0cmluZ1R5cGUiLCJzdHJpbmciLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGVkU3RyaW5nIiwiZW5jb2RlIiwiYnl0ZUxlbmd0aCIsImJ1ZiIsIlVpbnQ4QXJyYXkiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJ0eXBlZEFycmF5VHlwZSIsIlVpbnQxNlR5cGUiLCJVaW50MTZBcnJheSIsInNldFVpbnQxNiIsImdldFVpbnQxNiIsIlVpbnQzMlR5cGUiLCJVaW50NjRUeXBlIiwiQmlnVWludDY0QXJyYXkiLCJzZXRCaWdVaW50NjQiLCJnZXRCaWdVaW50NjQiLCJVaW50OFR5cGUiLCJzZXRVaW50OCIsImdldFVpbnQ4IiwiSW4iLCJPdXQiLCJJbk91dCIsImRyYWluV3JpdGVyIiwid3JpdGUiLCJwcmV2IiwiY3VycmVudCIsInRleHQiLCJpbmNsdWRlcyIsInNwbGl0IiwibGluZSIsInJlc3QiLCJXYXNpIiwiZW52IiwiaW5zdGFuY2UiLCJzdGRvdXRUZXh0Iiwic3RkZXJyVGV4dCIsImV4cG9ydHMiLCJlbnZpcm9uIiwiZW52aXJvbkJ1ZiIsIk9iamVjdCIsImVudHJpZXMiLCJrZXkiLCJlbnZWYXIiLCJieXRlcyIsImVudmlyb25Db3VudCIsImVudmlyb25CdWZTaXplIiwiZW52VmFycyIsInNpemUiLCJyZWR1Y2UiLCJhY2MiLCJydmFsIiwiZmQiLCJvZmZzZXRfbG93Iiwib2Zmc2V0X2hpZ2giLCJ3aGVuY2UiLCJuZXdPZmZzZXQiLCJpb3ZzIiwiaW92c0xlbiIsIm53cml0dGVuIiwiYnVmZmVycyIsIl8iLCJwdHIiLCJtZW1lb3J5TWFuYWdlciIsImJ1ZkxlbiIsInRleHREZWNvZGVyIiwid3JpdHRlbiIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsInN0YXQiLCJ1bmRlZmluZWQiLCJGRF9XUklURSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87UUNWQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyw0REFBZ0I7O0FBRXRDLFdBQVcsbUJBQU8sQ0FBQyxxREFBTTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsOEJBQThCO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN1NBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFD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Z0JBQTdEO0FBQ0EsV0FBS3NELGFBQUwsQ0FBbUIxSSxRQUFuQixDQUE0QjJNLFNBQTVCLENBQXNDNkUsSUFBSSxHQUFHLENBQTdDLEVBQWdEclIsK0NBQUksQ0FBQ3VGLE9BQUwsQ0FBYUMsTUFBN0QsRUFBcUUsSUFBckU7QUFDQSxXQUFLK0MsYUFBTCxDQUFtQjFJLFFBQW5CLENBQTRCaU8sWUFBNUIsQ0FBeUN1RCxJQUFJLEdBQUcsQ0FBaEQsRUFBbURyUiwrQ0FBSSxDQUFDNkYsTUFBTCxDQUFZMEwsUUFBL0QsRUFBeUUsSUFBekU7QUFDQSxXQUFLaEosYUFBTCxDQUFtQjFJLFFBQW5CLENBQTRCaU8sWUFBNUIsQ0FBeUN1RCxJQUFJLEdBQUcsRUFBaEQsRUFBb0RyUiwrQ0FBSSxDQUFDNkYsTUFBTCxDQUFZMEwsUUFBaEUsRUFBMEUsSUFBMUU7QUFDQSxhQUFPdlIsK0NBQUksQ0FBQ0MsUUFBWjtBQUNEO0FBdEhIOztBQUFBO0FBQUEsSSIsImZpbGUiOiJsaWIvaW5kZXguZGV2ZWxvcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIldhc2lNYXJzaGFsbGluZ1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJXYXNpTWFyc2hhbGxpbmdcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFZFUlNJT04gPSByZXF1aXJlKCcuL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5cbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9XG4gIHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nXG4gICAgPyBwYXRoLmpvaW4oX19kaXJuYW1lLCAnZmxvdy1vc3gtdicgKyBWRVJTSU9OLCAnZmxvdycpIDpcbiAgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4JyAmJiBwcm9jZXNzLmFyY2ggPT09ICd4NjQnXG4gICAgPyBwYXRoLmpvaW4oX19kaXJuYW1lLCAnZmxvdy1saW51eDY0LXYnICsgVkVSU0lPTiwgJ2Zsb3cnKSA6XG4gIHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgJiYgIHByb2Nlc3MuYXJjaCA9PT0gJ3g2NCdcbiAgICA/IHBhdGguam9pbihfX2Rpcm5hbWUsICdmbG93LXdpbjY0LXYnICsgVkVSU0lPTiwgJ2Zsb3cuZXhlJykgOlxuICBudWxsO1xuIiwiLy8gLmRpcm5hbWUsIC5iYXNlbmFtZSwgYW5kIC5leHRuYW1lIG1ldGhvZHMgYXJlIGV4dHJhY3RlZCBmcm9tIE5vZGUuanMgdjguMTEuMSxcbi8vIGJhY2twb3J0ZWQgYW5kIHRyYW5zcGxpdGVkIHdpdGggQmFiZWwsIHdpdGggYmFja3dhcmRzLWNvbXBhdCBmaXhlc1xuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiAnLic7XG4gIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuICB2YXIgaGFzUm9vdCA9IGNvZGUgPT09IDQ3IC8qLyovO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDE7IC0taSkge1xuICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgcmV0dXJuIGhhc1Jvb3QgPyAnLycgOiAnLic7XG4gIGlmIChoYXNSb290ICYmIGVuZCA9PT0gMSkge1xuICAgIC8vIHJldHVybiAnLy8nO1xuICAgIC8vIEJhY2t3YXJkcy1jb21wYXQgZml4OlxuICAgIHJldHVybiAnLyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZW5kKTtcbn07XG5cbmZ1bmN0aW9uIGJhc2VuYW1lKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcblxuICB2YXIgc3RhcnQgPSAwO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgaWYgKHBhdGguY2hhckNvZGVBdChpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAvLyBwYXRoIGNvbXBvbmVudFxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICBlbmQgPSBpICsgMTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgcmV0dXJuICcnO1xuICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbn1cblxuLy8gVXNlcyBhIG1peGVkIGFwcHJvYWNoIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSwgYXMgZXh0IGJlaGF2aW9yIGNoYW5nZWRcbi8vIGluIG5ldyBOb2RlLmpzIHZlcnNpb25zLCBzbyBvbmx5IGJhc2VuYW1lKCkgYWJvdmUgaXMgYmFja3BvcnRlZCBoZXJlXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24gKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IGJhc2VuYW1lKHBhdGgpO1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgdmFyIHN0YXJ0RG90ID0gLTE7XG4gIHZhciBzdGFydFBhcnQgPSAwO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4gIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXG4gIHZhciBwcmVEb3RTdGF0ZSA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAvLyBleHRlbnNpb25cbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSA0NiAvKi4qLykge1xuICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSlcbiAgICAgICAgICBzdGFydERvdCA9IGk7XG4gICAgICAgIGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKVxuICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgIC8vIGhhdmUgYSBnb29kIGNoYW5jZSBhdCBoYXZpbmcgYSBub24tZW1wdHkgZXh0ZW5zaW9uXG4gICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fFxuICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgeyAkRGF0YVZpZXcgfSBmcm9tICdmbG93LWJpbidcblxuZXhwb3J0IGNsYXNzIE1lbW9yeU1hbmFnZXIge1xuICBtZW1vcnk6IFdlYkFzc2VtYmx5Lk1lbW9yeVxuICBtYWxsb2M6IChieXRlTGVuZ3RoOiBudW1iZXIpID0+IG51bWJlclxuICBmcmVlOiAoYWRkcmVzczogbnVtYmVyKSA9PiB2b2lkXG4gIGRhdGFWaWV3OiAkRGF0YVZpZXdcblxuICBjb25zdHJ1Y3RvciAobWVtb3J5OiBXZWJBc3NlbWJseS5NZW1vcnksIG1hbGxvYzogKGJ5dGVMZW5ndGg6IG51bWJlcikgPT4gbnVtYmVyLCBmcmVlOiAoYWRkcmVzczogbnVtYmVyKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5tZW1vcnkgPSBtZW1vcnlcbiAgICB0aGlzLm1hbGxvYyA9IG1hbGxvY1xuICAgIHRoaXMuZnJlZSA9IGZyZWVcbiAgICB0aGlzLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHRoaXMubWVtb3J5LmJ1ZmZlcilcbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IFdBU0kgPSB7XG4gIC8vIE5vIGVycm9yIG9jY3VycmVkLiBTeXN0ZW0gY2FsbCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuICBFU1VDQ0VTUzogMCxcblxuICAvLyBFcnJvciBjb2Rlc1xuICBFUlJOTzoge1xuICAgIC8vIEFyZ3VtZW50IGxpc3QgdG9vIGxvbmcuXG4gICAgJzJCSUcnOiAxLFxuXG4gICAgLy8gUGVybWlzc2lvbiBkZW5pZWQuXG4gICAgQUNDRVM6IDIsXG5cbiAgICAvLyBBZGRyZXNzIGluIHVzZS5cbiAgICBBRERSSU5VU0U6IDMsXG5cbiAgICAvLyBBZGRyZXNzIG5vdCBhdmFpbGFibGUuXG4gICAgQUREUk5PVEFWQUlMOiA0LFxuXG4gICAgLy8gQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZC5cbiAgICBBRk5PU1VQUE9SVDogNSxcblxuICAgIC8vIFJlc291cmNlIHVuYXZhaWxhYmxlLCBvciBvcGVyYXRpb24gd291bGQgYmxvY2suXG4gICAgQUdBSU46IDYsXG5cbiAgICAvLyBDb25uZWN0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MuXG4gICAgQUxSRUFEWTogNyxcblxuICAgIC8vIEJhZCBmaWxlIGRlc2NyaXB0b3IuXG4gICAgQkFERjogOCxcblxuICAgIC8vIEJhZCBtZXNzYWdlLlxuICAgIEJBRE1TRzogOSxcblxuICAgIC8vIERldmljZSBvciByZXNvdXJjZSBidXN5LlxuICAgIEJVU1k6IDEwLFxuXG4gICAgLy8gT3BlcmF0aW9uIGNhbmNlbGVkLlxuICAgIENBTkNFTEVEOiAxMSxcblxuICAgIC8vIE5vIGNoaWxkIHByb2Nlc3Nlcy5cbiAgICBDSElMRDogMTIsXG5cbiAgICAvLyBDb25uZWN0aW9uIGFib3J0ZWQuXG4gICAgQ09OTkFCT1JURUQ6IDEzLFxuXG4gICAgLy8gQ29ubmVjdGlvbiByZWZ1c2VkLlxuICAgIENPTk5SRUZVU0VEOiAxNCxcblxuICAgIC8vIENvbm5lY3Rpb24gcmVzZXQuXG4gICAgQ09OTlJFU0VUOiAxNSxcblxuICAgIC8vIFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyLlxuICAgIERFQURMSzogMTYsXG5cbiAgICAvLyBEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkLlxuICAgIERFU1RBRERSUkVROiAxNyxcblxuICAgIC8vIE1hdGhlbWF0aWNzIGFyZ3VtZW50IG91dCBvZiBkb21haW4gb2YgZnVuY3Rpb24uXG4gICAgRE9NOiAxOCxcblxuICAgIC8vIFJlc2VydmVkLlxuICAgIERRVU9UOiAxOSxcblxuICAgIC8vIEZpbGUgZXhpc3RzLlxuICAgIEVYSVNUOiAyMCxcblxuICAgIC8vIEJhZCBhZGRyZXNzLlxuICAgIEZBVUxUOiAyMSxcblxuICAgIC8vIEZpbGUgdG9vIGxhcmdlLlxuICAgIEZCSUc6IDIyLFxuXG4gICAgLy8gSG9zdCBpcyB1bnJlYWNoYWJsZS5cbiAgICBIT1NUVU5SRUFDSDogMjMsXG5cbiAgICAvLyBJZGVudGlmaWVyIHJlbW92ZWQuXG4gICAgSURSTTogMjQsXG5cbiAgICAvLyBJbGxlZ2FsIGJ5dGUgc2VxdWVuY2UuXG4gICAgSUxTRVE6IDI1LFxuXG4gICAgLy8gT3BlcmF0aW9uIGluIHByb2dyZXNzLlxuICAgIElOUFJPR1JFU1M6IDI2LFxuXG4gICAgLy8gSW50ZXJydXB0ZWQgZnVuY3Rpb24uXG4gICAgSU5UUjogMjcsXG5cbiAgICAvLyBJbnZhbGlkIGFyZ3VtZW50LlxuICAgIElOVkFMOiAyOCxcblxuICAgIC8vIEkvTyBlcnJvci5cbiAgICBJTzogMjksXG5cbiAgICAvLyBTb2NrZXQgaXMgY29ubmVjdGVkLlxuICAgIElTQ09OTjogMzAsXG5cbiAgICAvLyBJcyBhIGRpcmVjdG9yeS5cbiAgICBJU0RJUjogMzEsXG5cbiAgICAvLyBUb28gbWFueSBsZXZlbHMgb2Ygc3ltYm9saWMgbGlua3MuXG4gICAgTE9PUDogMzIsXG5cbiAgICAvLyBGaWxlIGRlc2NyaXB0b3IgdmFsdWUgdG9vIGxhcmdlLlxuICAgIE1GSUxFOiAzMyxcblxuICAgIC8vIFRvbyBtYW55IGxpbmtzLlxuICAgIE1MSU5LOiAzNCxcblxuICAgIC8vIE1lc3NhZ2UgdG9vIGxhcmdlLlxuICAgIE1TR1NJWkU6IDM1LFxuXG4gICAgLy8gUmVzZXJ2ZWQuXG4gICAgTVVMVElIT1A6IDM2LFxuXG4gICAgLy8gRmlsZW5hbWUgdG9vIGxvbmcuXG4gICAgTkFNRVRPT0xPTkc6IDM3LFxuXG4gICAgLy8gTmV0d29yayBpcyBkb3duLlxuICAgIE5FVERPV046IDM4LFxuXG4gICAgLy8gQ29ubmVjdGlvbiBhYm9ydGVkIGJ5IG5ldHdvcmsuXG4gICAgTkVUUkVTRVQ6IDM5LFxuXG4gICAgLy8gTmV0d29yayB1bnJlYWNoYWJsZS5cbiAgICBORVRVTlJFQUNIOiA0MCxcblxuICAgIC8vIFRvbyBtYW55IGZpbGVzIG9wZW4gaW4gc3lzdGVtLlxuICAgIE5GSUxFOiA0MSxcblxuICAgIC8vIE5vIGJ1ZmZlciBzcGFjZSBhdmFpbGFibGUuXG4gICAgTk9CVUZTOiA0MixcblxuICAgIC8vIE5vIHN1Y2ggZGV2aWNlLlxuICAgIE5PREVWOiA0MyxcblxuICAgIC8vIE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkuXG4gICAgTk9FTlQ6IDQ0LFxuXG4gICAgLy8gRXhlY3V0YWJsZSBmaWxlIGZvcm1hdCBlcnJvci5cbiAgICBOT0VYRUM6IDQ1LFxuXG4gICAgLy8gTm8gbG9ja3MgYXZhaWxhYmxlLlxuICAgIE5PTENLOiA0NixcblxuICAgIC8vIFJlc2VydmVkLlxuICAgIE5PTElOSzogNDcsXG5cbiAgICAvLyBOb3QgZW5vdWdoIHNwYWNlLlxuICAgIE5PTUVNOiA0OCxcblxuICAgIC8vIE5vIG1lc3NhZ2Ugb2YgdGhlIGRlc2lyZWQgdHlwZS5cbiAgICBOT01TRzogNDksXG5cbiAgICAvLyBQcm90b2NvbCBub3QgYXZhaWxhYmxlLlxuICAgIE5PUFJPVE9PUFQ6IDUwLFxuXG4gICAgLy8gTm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UuXG4gICAgTk9TUEM6IDUxLFxuXG4gICAgLy8gRnVuY3Rpb24gbm90IHN1cHBvcnRlZC5cbiAgICBOT1NZUzogNTIsXG5cbiAgICAvLyBUaGUgc29ja2V0IGlzIG5vdCBjb25uZWN0ZWQuXG4gICAgTk9UQ09OTjogNTMsXG5cbiAgICAvLyBOb3QgYSBkaXJlY3Rvcnkgb3IgYSBzeW1ib2xpYyBsaW5rIHRvIGEgZGlyZWN0b3J5LlxuICAgIE5PVERJUjogNTQsXG5cbiAgICAvLyBEaXJlY3Rvcnkgbm90IGVtcHR5LlxuICAgIE5PVEVNUFRZOiA1NSxcblxuICAgIC8vIFN0YXRlIG5vdCByZWNvdmVyYWJsZS5cbiAgICBOT1RSRUNPVkVSQUJMRTogNTYsXG5cbiAgICAvLyBOb3QgYSBzb2NrZXQuXG4gICAgTk9UU09DSzogNTcsXG5cbiAgICAvLyBOb3Qgc3VwcG9ydGVkLCBvciBvcGVyYXRpb24gbm90IHN1cHBvcnRlZCBvbiBzb2NrZXQuXG4gICAgTk9UU1VQOiA1OCxcblxuICAgIC8vIEluYXBwcm9wcmlhdGUgSS9PIGNvbnRyb2wgb3BlcmF0aW9uLlxuICAgIE5PVFRZOiA1OSxcblxuICAgIC8vIE5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MuXG4gICAgTlhJTzogNjAsXG5cbiAgICAvLyBWYWx1ZSB0b28gbGFyZ2UgdG8gYmUgc3RvcmVkIGluIGRhdGEgdHlwZS5cbiAgICBPVkVSRkxPVzogNjEsXG5cbiAgICAvLyBQcmV2aW91cyBvd25lciBkaWVkLlxuICAgIE9XTkVSREVBRDogNjIsXG5cbiAgICAvLyBPcGVyYXRpb24gbm90IHBlcm1pdHRlZC5cbiAgICBQRVJNOiA2MyxcblxuICAgIC8vIEJyb2tlbiBwaXBlLlxuICAgIFBJUEU6IDY0LFxuXG4gICAgLy8gUHJvdG9jb2wgZXJyb3IuXG4gICAgUFJPVE86IDY1LFxuXG4gICAgLy8gUHJvdG9jb2wgbm90IHN1cHBvcnRlZC5cbiAgICBQUk9UT05PU1VQUE9SVDogNjYsXG5cbiAgICAvLyBQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXQuXG4gICAgUFJPVE9UWVBFOiA2NyxcblxuICAgIC8vIFJlc3VsdCB0b28gbGFyZ2UuXG4gICAgUkFOR0U6IDY4LFxuXG4gICAgLy8gUmVhZC1vbmx5IGZpbGUgc3lzdGVtLlxuICAgIFJPRlM6IDY5LFxuXG4gICAgLy8gSW52YWxpZCBzZWVrLlxuICAgIFNQSVBFOiA3MCxcblxuICAgIC8vIE5vIHN1Y2ggcHJvY2Vzcy5cbiAgICBTUkNIOiA3MSxcblxuICAgIC8vIFJlc2VydmVkLlxuICAgIFNUQUxFOiA3MixcblxuICAgIC8vIENvbm5lY3Rpb24gdGltZWQgb3V0LlxuICAgIFRJTUVET1VUOiA3MyxcblxuICAgIC8vIFRleHQgZmlsZSBidXN5LlxuICAgIFRYVEJTWTogNzQsXG5cbiAgICAvLyBDcm9zcy1kZXZpY2UgbGluay5cbiAgICBYREVWOiA3NSxcblxuICAgIC8vIEV4dGVuc2lvbjogQ2FwYWJpbGl0aWVzIGluc3VmZmljaWVudC5cbiAgICBOT1RDQVBBQkxFOiA3NlxuXG4gIH0sXG4gIEZJTEVUWVBFOiB7XG4gICAgVU5LTk9XTjogMCxcbiAgICBCTE9DS19ERVZJQ0U6IDEsXG4gICAgQ0hBUkFDVEVSX0RFVklDRTogMixcbiAgICBESVJFQ1RPUlk6IDMsXG4gICAgUkVHVUxBUl9GSUxFOiA0LFxuICAgIFNPQ0tFVF9ER1JBTTogNSxcbiAgICBTT0NLRVRfU1RSRUFNOiA2LFxuICAgIFNZTUJPTElDX0xJTks6IDdcbiAgfSxcblxuICAvLyBGbGFncyBmb3IgZmlsZXMgZGVzY3JpcHRvcnMuXG4gIEZERkxBR1M6IHtcbiAgICAvLyBBcHBlbmQgbW9kZTogRGF0YSB3cml0dGVuIHRvIHRoZSBmaWxlIGlzIGFsd2F5cyBhcHBlbmRlZCB0byB0aGUgZmlsZSdzIGVuZC5cbiAgICBBUFBFTkQ6IDEsXG5cbiAgICAvLyBXcml0ZSBhY2NvcmRpbmcgdG8gc3luY2hyb25pemVkIEkvTyBkYXRhIGludGVncml0eSBjb21wbGV0aW9uLiBPbmx5IHRoZSBkYXRhIHN0b3JlZCBpbiB0aGUgZmlsZSBpcyBzeW5jaHJvbml6ZWQuXG4gICAgRFNZTkM6IDIsXG5cbiAgICAvLyBOb24tYmxvY2tpbmcgbW9kZS5cbiAgICBOT05CTE9DSzogNCxcblxuICAgIC8vIFN5bmNocm9uaXplZCByZWFkIEkvTyBvcGVyYXRpb25zLlxuICAgIFJTWU5DOiA4LFxuXG4gICAgLy8gV3JpdGUgYWNjb3JkaW5nIHRvIHN5bmNocm9uaXplZCBJL08gZmlsZSBpbnRlZ3JpdHkgY29tcGxldGlvbi4gSW5cbiAgICAvLyBhZGRpdGlvbiB0byBzeW5jaHJvbml6aW5nIHRoZSBkYXRhIHN0b3JlZCBpbiB0aGUgZmlsZSwgdGhlIGltcGxlbWVudGF0aW9uXG4gICAgLy8gbWF5IGFsc28gc3luY2hyb25vdXNseSB1cGRhdGUgdGhlIGZpbGUncyBtZXRhZGF0YS5cbiAgICBTWU5DOiAxNlxuICB9LFxuXG4gIC8vIEZsYWdzIGZvciByaWdodHNcbiAgUklHSFRTOiB7XG4gICAgRkQ6IHtcbiAgICAgIERBVEFTWU5DOiAxbixcbiAgICAgIFJFQUQ6IDJuLFxuICAgICAgU0VFSzogNG4sXG4gICAgICBGRFNUQVRfU0VUX0ZMQUdTOiA4bixcbiAgICAgIFNZTkM6IDE2bixcbiAgICAgIFRFTEw6IDMybixcbiAgICAgIFdSSVRFOiA2NG4sXG4gICAgICBBRFZJU0U6IDEyOG4sXG4gICAgICBBTExPQ0FURTogMjU2bixcbiAgICAgIFJFQURESVI6IDE2Mzg0bixcbiAgICAgIEZJTEVTVEFUX0dFVDogMjA5NzE1Mm4sXG4gICAgICBGSUxFU1RBVF9TRVRfU0laRTogNDE5NDMwNG4sXG4gICAgICBGSUxFU1RBVF9TRVRfVElNRVM6IDgzODg2MDhuXG4gICAgfSxcbiAgICBQQVRIOiB7XG4gICAgICBDUkVBVEVfRElSRUNUT1JZOiA1MTJuLFxuICAgICAgQ1JFQVRFX0ZJTEU6IDEwMjRuLFxuICAgICAgTElOS19TT1VSQ0U6IDIwNDhuLFxuICAgICAgTElOS19UQVJHRVQ6IDQwOTZuLFxuICAgICAgT1BFTjogODE5Mm4sXG4gICAgICBSRUFETElOSzogMzI3NjhuLFxuICAgICAgUkVOQU1FX1NPVVJDRTogNjU1MzZuLFxuICAgICAgUkVOQU1FX1RBUkdFVDogMTMxMDcybixcbiAgICAgIEZJTEVTVEFUX0dFVDogMjYyMTQ0bixcbiAgICAgIEZJTEVTVEFUX1NFVF9TSVpFOiA1MjQyODhuLFxuICAgICAgRklMRVNUQVRfU0VUX1RJTUVTOiAxMDQ4NTc2bixcbiAgICAgIFNZTUxJTks6IDE2Nzc3MjE2bixcbiAgICAgIFJFTU9WRV9ESVJFQ1RPUlk6IDMzNTU0NDMybixcbiAgICAgIFVOTElOS19GSUxFOiA2NzEwODg2NG5cbiAgICB9LFxuICAgIFBPTExfRkRfUkVBRFdSSVRFOiAxMzQyMTc3MjhuLFxuICAgIFNPQ0tfU0hVVERPV046IDI2ODQzNTQ1Nm5cbiAgfSxcbiAgQURWSUNFOiB7XG4gICAgLy8gVGhlIGFwcGxpY2F0aW9uIGhhcyBubyBhZHZpY2UgdG8gZ2l2ZSBvbiBpdHMgYmVoYXZpb3Igd2l0aCByZXNwZWN0IHRvIHRoZSBzcGVjaWZpZWQgZGF0YS5cbiAgICBOT1JNQUw6IDAsXG5cbiAgICAvLyBUaGUgYXBwbGljYXRpb24gZXhwZWN0cyB0byBhY2Nlc3MgdGhlIHNwZWNpZmllZCBkYXRhIHNlcXVlbnRpYWxseSBmcm9tIGxvd2VyIG9mZnNldHMgdG8gaGlnaGVyIG9mZnNldHMuXG4gICAgU0VRVUVOVElBTDogMSxcblxuICAgIC8vIFRoZSBhcHBsaWNhdGlvbiBleHBlY3RzIHRvIGFjY2VzcyB0aGUgc3BlY2lmaWVkIGRhdGEgaW4gYSByYW5kb20gb3JkZXIuXG4gICAgUkFORE9NOiAyLFxuXG4gICAgLy8gVGhlIGFwcGxpY2F0aW9uIGV4cGVjdHMgdG8gYWNjZXNzIHRoZSBzcGVjaWZpZWQgZGF0YSBpbiB0aGUgbmVhciBmdXR1cmUuXG4gICAgV0lMTE5FRUQ6IDMsXG5cbiAgICAvLyBUaGUgYXBwbGljYXRpb24gZXhwZWN0cyB0aGF0IGl0IHdpbGwgbm90IGFjY2VzcyB0aGUgc3BlY2lmaWVkIGRhdGEgaW4gdGhlIG5lYXIgZnV0dXJlLlxuICAgIERPTlRORUVEOiA0LFxuXG4gICAgLy8gVGhlIGFwcGxpY2F0aW9uIGV4cGVjdHMgdG8gYWNjZXNzIHRoZSBzcGVjaWZpZWQgZGF0YSBvbmNlIGFuZCB0aGVuIG5vdCByZXVzZSBpdCB0aGVyZWFmdGVyLlxuICAgIE5PUkVVU0U6IDVcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgU1RET1VUID0gMVxuZXhwb3J0IGNvbnN0IFNUREVSUiA9IDJcbiIsImV4cG9ydCB7IE1lbW9yeU1hbmFnZXIgfSBmcm9tICcuL01lbW9yeU1hbmFnZXInXG5cbmV4cG9ydCB7XG4gIFR5cGUsXG4gIFZhbHVlVHlwZSxcbiAgSW50OFR5cGUsXG4gIEludDE2VHlwZSxcbiAgSW50MzJUeXBlLFxuICBJbnQ2NFR5cGUsXG4gIFVpbnQ4VHlwZSxcbiAgVWludDE2VHlwZSxcbiAgVWludDMyVHlwZSxcbiAgVWludDY0VHlwZSxcbiAgRmxvYXQzMlR5cGUsXG4gIEZsb2F0NjRUeXBlLFxuICBSZWZlcmVuY2VUeXBlLFxuICBTdHJpbmdUeXBlLFxuICBQb2ludGVyLFxuICBQb2ludGVyVHlwZSxcbiAgQXJyYXlUeXBlLFxuICBBcmd1bWVudERlZixcbiAgSW4sXG4gIE91dCxcbiAgSW5PdXQsXG4gIEZ1bmN0aW9uUHJvdG90eXBlXG59IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCB7IFdhc2kgfSBmcm9tICcuL3dhc2knXG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgeyBNZW1vcnlNYW5hZ2VyIH0gZnJvbSAnLi4vTWVtb3J5TWFuYWdlcidcblxuaW1wb3J0IHsgVmFsdWVUeXBlIH0gZnJvbSAnLi9WYWx1ZVR5cGUnXG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnLi9UeXBlJ1xuXG4vKipcbiAqIEFuIGFyZ3VtZW50IGRlZmluaXRpb24gaXMgdXNlZCBieSB7QGxpbmsgRnVuY3Rpb25Qcm90b3R5cGV9IHRvIGRlZmluZSB0aGVcbiAqIGFyZ3VtZW50cyB0byBhIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgQXJndW1lbnREZWY8VD4ge1xuICB0eXBlOiBUeXBlPFQ+XG4gIGlzSW5wdXQ6IGJvb2xlYW5cbiAgaXNPdXRwdXQ6IGJvb2xlYW5cblxuICAvKipcbiAgICogQ29uc3RydWN0IGFuIGFyZ3VtZW50IGRlZmludGlvbi4gVGhlIHtAbGluayBJbn0sIHtAbGluayBPdXR9LCBhbmQge0BsaW5rIEluT3V0fVxuICAgKiBoZWxwZXIgY2xhc3NlcyBzaG91bGQgYmUgdXNlZCB0byBjb25zdHJ1Y3QgYXJndW1lbnQgZGVmaW5pdGlvbnMgYXMgdGhleSBhcmVcbiAgICogc2VtYW50aWNhbGx5IGNsZWFyZXIgYW5kIGF2b2lkIHRoZSBwb3NzaWJpbGl0eSBvZiBzZXR0aW5nIGJvdGggYGlzSW5wdXRgIGFuZFxuICAgKiBgaXNPdXRwdXRgIHRvIGBmYWxzZWAuXG4gICAqIEBwYXJhbSB7VHlwZX0gdHlwZSBUaGUgYXJndW1lbnQgdHlwZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzSW5wdXQgSWYgdHJ1ZSB0aGUgYXJndW1lbnQgcHJvdmlkZXMgZGF0YSB0byB0aGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtib29sZWFufSBpc091dHB1dCBJZiB0cnVlIHRoZSBhcmd1bWVudCBpcyBwb3VsYXRlZCBieSB0aGUgZnVuY3Rpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yICh0eXBlOiBUeXBlPFQ+LCBpc0lucHV0OiBib29sZWFuLCBpc091dHB1dDogYm9vbGVhbikge1xuICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICB0aGlzLmlzSW5wdXQgPSBpc0lucHV0XG4gICAgdGhpcy5pc091dHB1dCA9IGlzT3V0cHV0XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIEphdmFTY3JpcHQgdmFsdWUgd2hpY2ggY2FuIGJlIHBhc3NlZCB0byBhXG4gICAqIFdlYkFzc2VtYmx5IG1vZHVsZSBpbnN0YW5jZS4gRm9yIHZhbHVlIHR5cGVzIHRoaXMgaXMgdHlwaWNhbGx5IHRoZSB2YWx1ZVxuICAgKiBpdHNlbGYuIEZvciByZWZyZW5jZSB0eXBlcyBtZW1vcnkgd2lsbCBiZSBhbGxvY2F0ZWQgaW4gdGhlIGluc3RhbmNlLCBhbmRcbiAgICogdGhlIGRhdGEgd2lsbCBiZSBjb3BpZWQuXG4gICAqIEBwYXJhbSB7VH0gdmFsdWUgVGhlIHZhbHVlIGZvciB3aGljaCBhIFdlYkFzc2VtYmx5IHZhbHVlIHNob3VsZCBiZSBjcmVhdGVkXG4gICAqIEBwYXJhbSB7TWVtb3J5TWFuYWdlcn0gbWVtb3J5TWFuYWdlciBBIGNsYXNzIHdoaWNoIHByb3ZpZGVzIG1ldGhvZHMgdG9cbiAgICogICAgbWFuYWdlIHRoZSBtZW1vcnkgb2YgYSBXZWJBc3NlbWJseSBtb2R1bGUuXG4gICAqL1xuICBtYXJzaGFsbCAodmFsdWU6IFQsIG1lbW9yeU1hbmFnZXI6IE1lbW9yeU1hbmFnZXIpOiBudW1iZXJ8VCB7XG4gICAgaWYgKHRoaXMudHlwZSBpbnN0YW5jZW9mIFZhbHVlVHlwZSkge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSBlbHNlIGlmICh0aGlzLmlzSW5wdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUubWFyc2hhbGwodmFsdWUsIG1lbW9yeU1hbmFnZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuYWxsb2MobWVtb3J5TWFuYWdlciwgdmFsdWUpXG4gICAgfVxuICB9XG5cbiAgdW5tYXJzaGFsbCAoYWRkcmVzc09yVmFsdWU6IG51bWJlcnxULCBtZW1vcnlNYW5hZ2VyOiBNZW1vcnlNYW5hZ2VyLCB2YWx1ZTogP1QpOiBudW1iZXJ8P1Qge1xuICAgIGlmICh0aGlzLnR5cGUgaW5zdGFuY2VvZiBWYWx1ZVR5cGUpIHtcbiAgICAgIHJldHVybiBhZGRyZXNzT3JWYWx1ZVxuICAgIH1cblxuICAgIGlmICh0aGlzLmlzT3V0cHV0KSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dCBwdXQgYXJndW1lbnQgbWlzc2luZycpXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGFkZHJlc3NPclZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGFkZHJlc3MgdG8gYmUgYSBudW1iZXInKVxuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50eXBlLnVubWFyc2hhbGwoYWRkcmVzc09yVmFsdWUsIG1lbW9yeU1hbmFnZXIsIHZhbHVlKVxuICAgICAgdGhpcy50eXBlLmNvcHkodmFsdWUsIHJlc3VsdClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBhZGRyZXNzT3JWYWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhZGRyZXNzIHRvIGJlIGEgbnVtYmVyJylcbiAgICAgIH1cbiAgICAgIHRoaXMudHlwZS5mcmVlKGFkZHJlc3NPclZhbHVlLCBtZW1vcnlNYW5hZ2VyLCB2YWx1ZSlcbiAgICB9XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5cbmltcG9ydCB7IE1lbW9yeU1hbmFnZXIgfSBmcm9tICcuLi9NZW1vcnlNYW5hZ2VyJ1xuXG5pbXBvcnQgeyBSZWZlcmVuY2VUeXBlIH0gZnJvbSAnLi9SZWZlcmVuY2VUeXBlJ1xuaW1wb3J0IHsgVHlwZSB9IGZyb20gJy4vVHlwZSdcblxuZXhwb3J0IGNsYXNzIEFycmF5VHlwZTxUPiBleHRlbmRzIFJlZmVyZW5jZVR5cGU8QXJyYXk8VD4+IHtcbiAgdHlwZTogVHlwZTxUPlxuICBsZW5ndGg6ID9udW1iZXJcblxuICBjb25zdHJ1Y3RvciAodHlwZTogVHlwZTxUPiwgbGVuZ3RoOiBudW1iZXIpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICBhbGxvYyAobWVtb3J5TWFuYWdlcjogTWVtb3J5TWFuYWdlciwgYXJyYXk6ID9BcnJheTxUPik6IG51bWJlciB7XG4gICAgaWYgKHRoaXMubGVuZ3RoICE9IG51bGwgJiYgYXJyYXkgIT0gbnVsbCAmJiB0aGlzLmxlbmd0aCAhPT0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBhcnJheSBsZW5ndGgnKVxuICAgIH1cblxuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5ICE9IG51bGwgPyBhcnJheS5sZW5ndGggOiB0aGlzLmxlbmd0aFxuICAgIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1Vua25vd24gbGVuZ3RoJylcbiAgICB9XG4gICAgcmV0dXJuIG1lbW9yeU1hbmFnZXIubWFsbG9jKGxlbmd0aCAqIHRoaXMudHlwZS5UeXBlZEFycmF5VHlwZS5CWVRFU19QRVJfRUxFTUVOVClcbiAgfVxuXG4gIGZyZWUgKGFkZHJlc3M6IG51bWJlciwgbWVtb3J5TWFuYWdlcjogTWVtb3J5TWFuYWdlciwgYXJyYXk6ID9BcnJheTxUPik6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBhcnJheSAhPSBudWxsID8gYXJyYXkubGVuZ3RoIDogdGhpcy5sZW5ndGhcbiAgICAgIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua253b24gbGVuZ3RoIGZvciBhcnJheScpXG4gICAgICB9XG4gICAgICBpZiAodGhpcy50eXBlIGluc3RhbmNlb2YgUmVmZXJlbmNlVHlwZSkge1xuICAgICAgICBjb25zdCB0eXBlZEFycmF5ID0gbmV3IHRoaXMudHlwZS5UeXBlZEFycmF5VHlwZShtZW1vcnlNYW5hZ2VyLm1lbW9yeS5idWZmZXIsIGFkZHJlc3MsIGxlbmd0aClcbiAgICAgICAgdHlwZWRBcnJheS5mb3JFYWNoKGl0ZW0gPT4gdGhpcy50eXBlLmZyZWUoaXRlbSwgbWVtb3J5TWFuYWdlcikpXG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIG1lbW9yeU1hbmFnZXIuZnJlZShhZGRyZXNzKVxuICAgIH1cbiAgfVxuXG4gIG1hcnNoYWxsIChhcnJheTogQXJyYXk8VD4sIG1lbW9yeU1hbmFnZXI6IE1lbW9yeU1hbmFnZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLmFsbG9jKG1lbW9yeU1hbmFnZXIsIGFycmF5KVxuXG4gICAgY29uc3QgdHlwZWRBcnJheSA9IG5ldyB0aGlzLnR5cGUuVHlwZWRBcnJheVR5cGUobWVtb3J5TWFuYWdlci5tZW1vcnkuYnVmZmVyLCBhZGRyZXNzLCBhcnJheS5sZW5ndGgpXG4gICAgaWYgKHRoaXMudHlwZSBpbnN0YW5jZW9mIFJlZmVyZW5jZVR5cGUpIHtcbiAgICAgIGFycmF5LmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgdHlwZWRBcnJheVtpXSA9IHRoaXMudHlwZS5tYXJzaGFsbChpdGVtLCBtZW1vcnlNYW5hZ2VyKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZWRBcnJheS5zZXQoYXJyYXkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZHJlc3NcbiAgfVxuXG4gIHVubWFyc2hhbGwgKGFkZHJlc3M6IG51bWJlciwgbWVtb3J5TWFuYWdlcjogTWVtb3J5TWFuYWdlciwgYXJyYXk6ID9BcnJheTxUPik6IEFycmF5PFQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbGVuZ3RoID0gYXJyYXkgIT0gbnVsbCA/IGFycmF5Lmxlbmd0aCA6IHRoaXMubGVuZ3RoXG4gICAgICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtud29uIGxlbmd0aCBmb3IgYXJyYXknKVxuICAgICAgfVxuICAgICAgY29uc3QgdHlwZWRBcnJheSA9IG5ldyB0aGlzLnR5cGUuVHlwZWRBcnJheVR5cGUobWVtb3J5TWFuYWdlci5tZW1vcnkuYnVmZmVyLCBhZGRyZXNzLCBsZW5ndGgpXG4gICAgICByZXR1cm4gdGhpcy50eXBlIGluc3RhbmNlb2YgUmVmZXJlbmNlVHlwZVxuICAgICAgICA/IEFycmF5LmZyb20odHlwZWRBcnJheSwgeCA9PiB0aGlzLnR5cGUudW5tYXJzaGFsbCh4LCBtZW1vcnlNYW5hZ2VyKSlcbiAgICAgICAgOiBBcnJheS5mcm9tKHR5cGVkQXJyYXkpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIG1lbW9yeU1hbmFnZXIuZnJlZShhZGRyZXNzKVxuICAgIH1cbiAgfVxuXG4gIGNvcHkgKGRlc3Q6IEFycmF5PFQ+LCBzb3VyY2U6IEFycmF5PFQ+KTogQXJyYXk8VD4ge1xuICAgIGRlc3Quc3BsaWNlKDAsIGRlc3QubGVuZ3RoLCAuLi5zb3VyY2UpXG4gICAgcmV0dXJuIGRlc3RcbiAgfVxufVxuIiwiLy8gQGZsb3dcblxuaW1wb3J0IHsgTWVtb3J5TWFuYWdlciB9IGZyb20gJy4uL01lbW9yeU1hbmFnZXInXG5cbmltcG9ydCB7IFZhbHVlVHlwZSB9IGZyb20gJy4vVmFsdWVUeXBlJ1xuXG5leHBvcnQgY2xhc3MgRmxvYXQzMlR5cGUgZXh0ZW5kcyBWYWx1ZVR5cGU8bnVtYmVyPiB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcihGbG9hdDMyQXJyYXkpXG4gIH1cblxuICBtYXJzaGFsbCAodmFsdWU6IG51bWJlciwgbWVtb3J5TWFuYWdlcjogTWVtb3J5TWFuYWdlcik6IG51bWJlciB7XG4gICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuYWxsb2MobWVtb3J5TWFuYWdlcilcbiAgICBtZW1vcnlNYW5hZ2VyLmRhdGFWaWV3LnNldEZsb2F0MzIoYWRkcmVzcywgdmFsdWUpXG4gICAgcmV0dXJuIGFkZHJlc3NcbiAgfVxuXG4gIHVubWFyc2hhbGwgKGFkZHJlc3M6IG51bWJlciwgbWVtb3J5TWFuYWdlcjogTWVtb3J5TWFuYWdlcik6IG51bWJlciB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBtZW1vcnlNYW5hZ2VyLmRhdGFWaWV3LmdldEZsb2F0MzIoYWRkcmVzcylcbiAgICB9IGZpbmFsbHkge1xuICAgICAgbWVtb3J5TWFuYWdlci5mcmVlKGFkZHJlc3MpXG4gICAgfVxuICB9XG59XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgeyBNZW1vcnlNYW5hZ2VyIH0gZnJvbSAnLi4vTWVtb3J5TWFuYWdlcidcblxuaW1wb3J0IHsgVmFsdWVUeXBlIH0gZnJvbSAnLi9WYWx1ZVR5cGUnXG5cbmV4cG9ydCBjbGFzcyBGbG9hdDY0VHlwZSBleHRlbmRzIFZhbHVlVHlwZTxudW1iZXI+IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKEZsb2F0NjRBcnJheSlcbiAgfVxuXG4gIG1hcnNoYWxsICh2YWx1ZTogbnVtYmVyLCBtZW1vcnlNYW5hZ2VyOk1lbW9yeU1hbmFnZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLmFsbG9jKG1lbW9yeU1hbmFnZXIpXG4gICAgbWVtb3J5TWFuYWdlci5kYXRhVmlldy5zZXRGbG9hdDY0KGFkZHJlc3MsIHZhbHVlKVxuICAgIHJldHVybiBhZGRyZXNzXG4gIH1cblxuICB1bm1hcnNoYWxsIChhZGRyZXNzOiBudW1iZXIsIG1lbW9yeU1hbmFnZXI6IE1lbW9yeU1hbmFnZXIpOiBudW1iZXIge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbWVtb3J5TWFuYWdlci5kYXRhVmlldy5nZXRGbG9hdDY0KGFkZHJlc3MpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIG1lbW9yeU1hbmFnZXIuZnJlZShhZGRyZXNzKVxuICAgIH1cbiAgfVxufVxuIiwiLy8gQGZsb3dcblxuaW1wb3J0IHsgTWVtb3J5TWFuYWdlciB9IGZyb20gJy4uL01lbW9yeU1hbmFnZXInXG5cbmltcG9ydCB7IEFyZ3VtZW50RGVmIH0gZnJvbSAnLi9Bcmd1bWVudERlZidcbmltcG9ydCB7IFR5cGUgfSBmcm9tICcuL1R5cGUnXG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvblByb3RvdHlwZTxUPiB7XG4gIGFyZ0RlZnM6IEFycmF5PEFyZ3VtZW50RGVmPGFueT4+XG4gIHJldHVybnM6ID9UeXBlPFQ+XG5cbiAgY29uc3RydWN0b3IgKGFyZ0RlZnM6IEFycmF5PEFyZ3VtZW50RGVmPGFueT4+LCByZXR1cm5zOiA/VHlwZTxUPikge1xuICAgIHRoaXMuYXJnRGVmcyA9IGFyZ0RlZnNcbiAgICB0aGlzLnJldHVybnMgPSByZXR1cm5zXG4gIH1cblxuICBpbnZva2UgKG1lbW9yeU1hbmFnZXI6IE1lbW9yeU1hbmFnZXIsIGZ1bmM6ICguLi5hcmdzOiBBcnJheTxhbnk+KSA9PiBhbnksIC4uLmFyZ3M6IEFycmF5PGFueT4pOiA/VCB7XG4gICAgaWYgKHRoaXMuYXJnRGVmcy5sZW5ndGggIT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzJylcbiAgICB9XG5cbiAgICBjb25zdCBtYXJzaGFsbGVkQXJncyA9IGFyZ3MubWFwKChhcmcsIGkpID0+XG4gICAgICB0aGlzLmFyZ0RlZnNbaV0ubWFyc2hhbGwoYXJnLCBtZW1vcnlNYW5hZ2VyKSlcblxuICAgIGNvbnN0IHJlc3VsdCA9IGZ1bmMoLi4ubWFyc2hhbGxlZEFyZ3MpXG5cbiAgICBhcmdzLmZvckVhY2goKGFyZywgaSkgPT5cbiAgICAgIHRoaXMuYXJnRGVmc1tpXS51bm1hcnNoYWxsKG1hcnNoYWxsZWRBcmdzW2ldLCBtZW1vcnlNYW5hZ2VyLCBhcmcpKVxuXG4gICAgaWYgKHRoaXMucmV0dXJucyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXR1cm5zLnVubWFyc2hhbGwocmVzdWx0LCBtZW1vcnlNYW5hZ2VyKVxuICAgIH1cbiAgfVxufVxuIiwiLy8gQGZsb3dcblxuaW1wb3J0IHsgTWVtb3J5TWFuYWdlciB9IGZyb20gJy4uL01lbW9yeU1hbmFnZXInXG5cbmltcG9ydCB7IFZhbHVlVHlwZSB9IGZyb20gJy4vVmFsdWVUeXBlJ1xuXG5leHBvcnQgY2xhc3MgSW50MTZUeXBlIGV4dGVuZHMgVmFsdWVUeXBlPG51bWJlcj4ge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoSW50OEFycmF5KVxuICB9XG5cbiAgbWFyc2hhbGwgKHZhbHVlOiBudW1iZXIsIG1lbW9yeU1hbmFnZXI6IE1lbW9yeU1hbmFnZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLmFsbG9jKG1lbW9yeU1hbmFnZXIpXG4gICAgbWVtb3J5TWFuYWdlci5kYXRhVmlldy5zZXRJbnQxNihhZGRyZXNzLCB2YWx1ZSlcbiAgICByZXR1cm4gYWRkcmVzc1xuICB9XG5cbiAgdW5tYXJzaGFsbCAoYWRkcmVzczogbnVtYmVyLCBtZW1vcnlNYW5hZ2VyOiBNZW1vcnlNYW5hZ2VyKTogbnVtYmVyIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG1lbW9yeU1hbmFnZXIuZGF0YVZpZXcuZ2V0SW50MTYoYWRkcmVzcylcbiAgICB9IGZpbmFsbHkge1xuICAgICAgbWVtb3J5TWFuYWdlci5mcmVlKGFkZHJlc3MpXG4gICAgfVxuICB9XG59XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgeyBNZW1vcnlNYW5hZ2VyIH0gZnJvbSAnLi4vTWVtb3J5TWFuYWdlcidcblxuaW1wb3J0IHsgVmFsdWVUeXBlIH0gZnJvbSAnLi9WYWx1ZVR5cGUnXG5cbmV4cG9ydCBjbGFzcyBJbnQzMlR5cGUgZXh0ZW5kcyBWYWx1ZVR5cGU8bnVtYmVyPiB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcihJbnQzMkFycmF5KVxuICB9XG5cbiAgbWFyc2hhbGwgKHZhbHVlOiBudW1iZXIsIG1lbW9yeU1hbmFnZXI6IE1lbW9yeU1hbmFnZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLmFsbG9jKG1lbW9yeU1hbmFnZXIpXG4gICAgbWVtb3J5TWFuYWdlci5kYXRhVmlldy5zZXRJbnQzMihhZGRyZXNzLCB2YWx1ZSlcbiAgICByZXR1cm4gYWRkcmVzc1xuICB9XG5cbiAgdW5tYXJzaGFsbCAoYWRkcmVzczogbnVtYmVyLCBtZW1vcnlNYW5hZ2VyOiBNZW1vcnlNYW5hZ2VyKTogbnVtYmVyIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG1lbW9yeU1hbmFnZXIuZGF0YVZpZXcuZ2V0SW50MzIoYWRkcmVzcylcbiAgICB9IGZpbmFsbHkge1xuICAgICAgbWVtb3J5TWFuYWdlci5mcmVlKGFkZHJlc3MpXG4gICAgfVxuICB9XG59XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgdHlwZSB7IEJpZ0ludDY0QXJyYXkgfSBmcm9tICdmbG93LWJpbidcblxuaW1wb3J0IHsgTWVtb3J5TWFuYWdlciB9IGZyb20gJy4uL01lbW9yeU1hbmFnZXInXG5cbmltcG9ydCB7IFZhbHVlVHlwZSB9IGZyb20gJy4vVmFsdWVUeXBlJ1xuXG5leHBvcnQgY2xhc3MgSW50NjRUeXBlIGV4dGVuZHMgVmFsdWVUeXBlPG51bWJlcj4ge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIHN1cGVyKEJpZ0ludDY0QXJyYXkpXG4gIH1cblxuICBtYXJzaGFsbCAodmFsdWU6IG51bWJlciwgbWVtb3J5TWFuYWdlcjogTWVtb3J5TWFuYWdlcik6IG51bWJlciB7XG4gICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuYWxsb2MobWVtb3J5TWFuYWdlcilcbiAgICBtZW1vcnlNYW5hZ2VyLmRhdGFWaWV3LnNldEJpZ0ludDY0KGFkZHJlc3MsIHZhbHVlKVxuICAgIHJldHVybiBhZGRyZXNzXG4gIH1cblxuICB1bm1hcnNoYWxsIChhZGRyZXNzOiBudW1iZXIsIG1lbW9yeU1hbmFnZXI6IE1lbW9yeU1hbmFnZXIpOiBudW1iZXIge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbWVtb3J5TWFuYWdlci5kYXRhVmlldy5nZXRCaWdJbnQ2NChhZGRyZXNzKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBtZW1vcnlNYW5hZ2VyLmZyZWUoYWRkcmVzcylcbiAgICB9XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5cbmltcG9ydCB7IE1lbW9yeU1hbmFnZXIgfSBmcm9tICcuLi9NZW1vcnlNYW5hZ2VyJ1xuXG5pbXBvcnQgeyBWYWx1ZVR5cGUgfSBmcm9tICcuL1ZhbHVlVHlwZSdcblxuZXhwb3J0IGNsYXNzIEludDhUeXBlIGV4dGVuZHMgVmFsdWVUeXBlPG51bWJlcj4ge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoSW50OEFycmF5KVxuICB9XG5cbiAgbWFyc2hhbGwgKHZhbHVlOiBudW1iZXIsIG1lbW9yeU1hbmFnZXI6IE1lbW9yeU1hbmFnZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLmFsbG9jKG1lbW9yeU1hbmFnZXIpXG4gICAgbWVtb3J5TWFuYWdlci5kYXRhVmlldy5zZXRJbnQ4KGFkZHJlc3MsIHZhbHVlKVxuICAgIHJldHVybiBhZGRyZXNzXG4gIH1cblxuICB1bm1hcnNoYWxsIChhZGRyZXNzOiBudW1iZXIsIG1lbW9yeU1hbmFnZXI6IE1lbW9yeU1hbmFnZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG1lbW9yeU1hbmFnZXIuZGF0YVZpZXcuZ2V0SW50OChhZGRyZXNzKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBtZW1vcnlNYW5hZ2VyLmZyZWUoYWRkcmVzcylcbiAgICB9XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5cbmV4cG9ydCBjbGFzcyBQb2ludGVyPFQ+IHtcbiAgY29udGVudHM6IFRcblxuICBjb25zdHJ1Y3RvciAoY29udGVudHM6IFQpIHtcbiAgICB0aGlzLmNvbnRlbnRzID0gY29udGVudHNcbiAgfVxufVxuIiwiLy8gQGZsb3dcblxuaW1wb3J0IHsgTWVtb3J5TWFuYWdlciB9IGZyb20gJy4uL01lbW9yeU1hbmFnZXInXG5cbmltcG9ydCB7IFBvaW50ZXIgfSBmcm9tICcuL1BvaW50ZXInXG5pbXBvcnQgeyBSZWZlcmVuY2VUeXBlIH0gZnJvbSAnLi9SZWZlcmVuY2VUeXBlJ1xuaW1wb3J0IHsgVHlwZSB9IGZyb20gJy4vVHlwZSdcblxuZXhwb3J0IGNsYXNzIFBvaW50ZXJUeXBlPFQ+IGV4dGVuZHMgUmVmZXJlbmNlVHlwZTxQb2ludGVyPFQ+PiB7XG4gIHR5cGU6IFR5cGU8VD5cblxuICBjb25zdHJ1Y3RvciAodHlwZTogVHlwZTxUPikge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnR5cGUgPSB0eXBlXG4gIH1cblxuICBmcmVlIChhZGRyZXNzOiBudW1iZXIsIG1lbW9yeU1hbmFnZXI6IE1lbW9yeU1hbmFnZXIpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWFyc2hhbGxlZEFkZHJlc3MgPSBtZW1vcnlNYW5hZ2VyLmRhdGFWaWV3LmdldFVpbnQzMihhZGRyZXNzKVxuICAgICAgdGhpcy50eXBlLmZyZWUobWFyc2hhbGxlZEFkZHJlc3MsIG1lbW9yeU1hbmFnZXIpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIG1lbW9yeU1hbmFnZXIuZnJlZShhZGRyZXNzKVxuICAgIH1cbiAgfVxuXG4gIGFsbG9jIChtZW1vcnlNYW5hZ2VyOiBNZW1vcnlNYW5hZ2VyKTogbnVtYmVyIHtcbiAgICBjb25zdCBhZGRyZXNzID0gbWVtb3J5TWFuYWdlci5tYWxsb2MoVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpXG4gICAgcmV0dXJuIGFkZHJlc3NcbiAgfVxuXG4gIG1hcnNoYWxsICh2YWx1ZTogUG9pbnRlcjxUPiwgbWVtb3J5TWFuYWdlcjogTWVtb3J5TWFuYWdlcik6IG51bWJlciB7XG4gICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuYWxsb2MobWVtb3J5TWFuYWdlcilcbiAgICBjb25zdCBtYXJzaGFsbGVkQWRkcmVzcyA9IHRoaXMudHlwZS5tYXJzaGFsbCh2YWx1ZS5jb250ZW50cywgbWVtb3J5TWFuYWdlcilcbiAgICBtZW1vcnlNYW5hZ2VyLmRhdGFWaWV3LnNldFVpbnQzMihhZGRyZXNzLCBtYXJzaGFsbGVkQWRkcmVzcylcbiAgICByZXR1cm4gYWRkcmVzc1xuICB9XG5cbiAgdW5tYXJzaGFsbCAoYWRkcmVzczogbnVtYmVyLCBtZW1vcnlNYW5hZ2VyOiBNZW1vcnlNYW5hZ2VyKTogUG9pbnRlcjxUPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1hcnNoYWxsZWRBZGRyZXNzID0gbWVtb3J5TWFuYWdlci5kYXRhVmlldy5nZXRVaW50MzIoYWRkcmVzcylcbiAgICAgIHJldHVybiBuZXcgUG9pbnRlcih0aGlzLnR5cGUudW5tYXJzaGFsbChtYXJzaGFsbGVkQWRkcmVzcywgbWVtb3J5TWFuYWdlcikpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIG1lbW9yeU1hbmFnZXIuZnJlZShhZGRyZXNzKVxuICAgIH1cbiAgfVxuXG4gIGNvcHkgKGRlc3Q6IFBvaW50ZXI8VD4sIHNvdXJjZTogUG9pbnRlcjxUPik6IFBvaW50ZXI8VD4ge1xuICAgIGRlc3QuY29udGVudHMgPSBzb3VyY2UuY29udGVudHNcbiAgICByZXR1cm4gZGVzdFxuICB9XG59XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnLi9UeXBlJ1xuXG5leHBvcnQgY2xhc3MgUmVmZXJlbmNlVHlwZTxUPiBleHRlbmRzIFR5cGU8VD4ge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoVWludDMyQXJyYXkpXG4gIH1cbn1cbiIsIi8vIEBmbG93XG5cbmltcG9ydCB7IE1lbW9yeU1hbmFnZXIgfSBmcm9tICcuLi9NZW1vcnlNYW5hZ2VyJ1xuXG5pbXBvcnQgeyBSZWZlcmVuY2VUeXBlIH0gZnJvbSAnLi9SZWZlcmVuY2VUeXBlJ1xuXG5leHBvcnQgY2xhc3MgU3RyaW5nVHlwZSBleHRlbmRzIFJlZmVyZW5jZVR5cGU8c3RyaW5nPiB7XG4gIGZyZWUgKGFkZHJlc3M6IG51bWJlciwgbWVtb3J5TWFuYWdlcjogTWVtb3J5TWFuYWdlcik6IHZvaWQge1xuICAgIG1lbW9yeU1hbmFnZXIuZnJlZShhZGRyZXNzKVxuICB9XG5cbiAgLy8gQ29udmVydCBhIEphdmFTY3JpcHQgc3RyaW5nIHRvIGEgcG9pbnRlciB0byBtdWx0aSBieXRlIGNoYXJhY3RlciBhcnJheVxuICBtYXJzaGFsbCAoc3RyaW5nOiBzdHJpbmcsIG1lbW9yeU1hbmFnZXI6IE1lbW9yeU1hbmFnZXIpOiBudW1iZXIge1xuICAgIC8vIEVuY29kZSB0aGUgc3RyaW5nIGluIHV0Zi04LlxuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuICAgIGNvbnN0IGVuY29kZWRTdHJpbmcgPSBlbmNvZGVyLmVuY29kZShzdHJpbmcpXG4gICAgLy8gQ29weSB0aGUgc3RyaW5nIGludG8gbWVtb3J5IGFsbG9jYXRlZCBpbiB0aGUgV2ViQXNzZW1ibHlcbiAgICBjb25zdCBhZGRyZXNzID0gbWVtb3J5TWFuYWdlci5tYWxsb2MoZW5jb2RlZFN0cmluZy5ieXRlTGVuZ3RoICsgMSlcbiAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShtZW1vcnlNYW5hZ2VyLm1lbW9yeS5idWZmZXIsIGFkZHJlc3MsIGVuY29kZWRTdHJpbmcuYnl0ZUxlbmd0aCArIDEpXG4gICAgYnVmLnNldChlbmNvZGVkU3RyaW5nKVxuICAgIHJldHVybiBhZGRyZXNzXG4gIH1cblxuICAvLyBDb252ZXJ0IGEgbnVsbCB0ZXJtaW5hdGVkIHBvaW50ZXIgZnJvbSB0aGUgd2FzbSBtb2R1bGUgdG8gSmF2YVNjcmlwdCBzdHJpbmcuXG4gIHVubWFyc2hhbGwgKGFkZHJlc3M6IG51bWJlciwgbWVtb3J5TWFuYWdlcjogTWVtb3J5TWFuYWdlcik6IHN0cmluZyB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpbmQgdGhlIG51bWJlciBvZiBieXRlcyBiZWZvcmUgdGhlIG51bGwgdGVybWluYXRpb24gY2hhcmFjdGVyLlxuICAgICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobWVtb3J5TWFuYWdlci5tZW1vcnkuYnVmZmVyLCBhZGRyZXNzKVxuICAgICAgbGV0IGxlbmd0aCA9IDBcbiAgICAgIHdoaWxlIChidWZbbGVuZ3RoXSAhPT0gMCkge1xuICAgICAgICArK2xlbmd0aFxuICAgICAgfVxuICAgICAgLy8gRGVjb2RlIHRoZSBzdHJpbmdcbiAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobWVtb3J5TWFuYWdlci5tZW1vcnkuYnVmZmVyLCBhZGRyZXNzLCBsZW5ndGgpXG4gICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbiAgICAgIGNvbnN0IHN0cmluZyA9IGRlY29kZXIuZGVjb2RlKGFycmF5KVxuICAgICAgcmV0dXJuIHN0cmluZ1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBGcmVlIHRoZSBtZW1vcnlcbiAgICAgIG1lbW9yeU1hbmFnZXIuZnJlZShhZGRyZXNzKVxuICAgIH1cbiAgfVxufVxuIiwiLy8gQGZsb3dcblxuaW1wb3J0IHR5cGUgeyAkVHlwZWRBcnJheSwgQ2xhc3MgfSBmcm9tICdmbG93LWJpbidcblxuaW1wb3J0IHsgTWVtb3J5TWFuYWdlciB9IGZyb20gJy4uL01lbW9yeU1hbmFnZXInXG5cbmV4cG9ydCBjbGFzcyBUeXBlPFQ+IHtcbiAgVHlwZWRBcnJheVR5cGU6IENsYXNzPCRUeXBlZEFycmF5PlxuXG4gIGNvbnN0cnVjdG9yICh0eXBlZEFycmF5VHlwZTogQ2xhc3M8JFR5cGVkQXJyYXk+KSB7XG4gICAgdGhpcy5UeXBlZEFycmF5VHlwZSA9IHR5cGVkQXJyYXlUeXBlXG4gIH1cblxuICBhbGxvYyAobWVtb3J5TWFuYWdlcjogTWVtb3J5TWFuYWdlciwgYXJyYXk6ID9UKTogbnVtYmVyIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCcpXG4gIH1cblxuICBmcmVlIChhZGRyZXNzOiBudW1iZXIsIG1lbW9yeU1hbmFnZXI6IE1lbW9yeU1hbmFnZXIsIHZhbHVlOiA/VCk6IHZvaWQge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJylcbiAgfVxuXG4gIG1hcnNoYWxsICh2YWx1ZTogVCwgbWVtb3J5TWFuYWdlcjogTWVtb3J5TWFuYWdlcik6IG51bWJlcnxUIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCcpXG4gIH1cblxuICB1bm1hcnNoYWxsIChhZGRyZXNzOiBudW1iZXIsIG1lbW9yeU1hbmFnZXI6IE1lbW9yeU1hbmFnZXIsIHZhbHVlOiA/VCk6IFQge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJylcbiAgfVxuXG4gIGNvcHkgKGRlc3Q6IFQsIHNvdXJjZTogVCk6IFQge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJylcbiAgfVxufVxuIiwiLy8gQGZsb3dcblxuaW1wb3J0IHsgTWVtb3J5TWFuYWdlciB9IGZyb20gJy4uL01lbW9yeU1hbmFnZXInXG5cbmltcG9ydCB7IFZhbHVlVHlwZSB9IGZyb20gJy4vVmFsdWVUeXBlJ1xuXG5leHBvcnQgY2xhc3MgVWludDE2VHlwZSBleHRlbmRzIFZhbHVlVHlwZTxudW1iZXI+IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKFVpbnQxNkFycmF5KVxuICB9XG5cbiAgbWFyc2hhbGwgKHZhbHVlOiBudW1iZXIsIG1lbW9yeU1hbmFnZXI6IE1lbW9yeU1hbmFnZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLmFsbG9jKG1lbW9yeU1hbmFnZXIpXG4gICAgbWVtb3J5TWFuYWdlci5kYXRhVmlldy5zZXRVaW50MTYoYWRkcmVzcywgdmFsdWUpXG4gICAgcmV0dXJuIGFkZHJlc3NcbiAgfVxuXG4gIHVubWFyc2hhbGwgKGFkZHJlc3M6IG51bWJlciwgbWVtb3J5TWFuYWdlcjogTWVtb3J5TWFuYWdlcik6IG51bWJlciB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBtZW1vcnlNYW5hZ2VyLmRhdGFWaWV3LmdldFVpbnQxNihhZGRyZXNzKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBtZW1vcnlNYW5hZ2VyLmZyZWUoYWRkcmVzcylcbiAgICB9XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5cbmltcG9ydCB7IE1lbW9yeU1hbmFnZXIgfSBmcm9tICcuLi9NZW1vcnlNYW5hZ2VyJ1xuXG5pbXBvcnQgeyBWYWx1ZVR5cGUgfSBmcm9tICcuL1ZhbHVlVHlwZSdcblxuZXhwb3J0IGNsYXNzIFVpbnQzMlR5cGUgZXh0ZW5kcyBWYWx1ZVR5cGU8bnVtYmVyPiB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcihVaW50MzJBcnJheSlcbiAgfVxuXG4gIG1hcnNoYWxsICh2YWx1ZTogbnVtYmVyLCBtZW1vcnlNYW5hZ2VyOiBNZW1vcnlNYW5hZ2VyKTogbnVtYmVyIHtcbiAgICBjb25zdCBhZGRyZXNzID0gdGhpcy5hbGxvYyhtZW1vcnlNYW5hZ2VyKVxuICAgIG1lbW9yeU1hbmFnZXIuZGF0YVZpZXcuc2V0VWludDMyKGFkZHJlc3MsIHZhbHVlKVxuICAgIHJldHVybiBhZGRyZXNzXG4gIH1cblxuICB1bm1hcnNoYWxsIChhZGRyZXNzOiBudW1iZXIsIG1lbW9yeU1hbmFnZXI6IE1lbW9yeU1hbmFnZXIpOiBudW1iZXIge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbWVtb3J5TWFuYWdlci5kYXRhVmlldy5nZXRVaW50MzIoYWRkcmVzcylcbiAgICB9IGZpbmFsbHkge1xuICAgICAgbWVtb3J5TWFuYWdlci5mcmVlKGFkZHJlc3MpXG4gICAgfVxuICB9XG59XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgeyBNZW1vcnlNYW5hZ2VyIH0gZnJvbSAnLi4vTWVtb3J5TWFuYWdlcidcblxuaW1wb3J0IHsgVmFsdWVUeXBlIH0gZnJvbSAnLi9WYWx1ZVR5cGUnXG5cbmV4cG9ydCBjbGFzcyBVaW50NjRUeXBlIGV4dGVuZHMgVmFsdWVUeXBlPG51bWJlcj4ge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIHN1cGVyKEJpZ1VpbnQ2NEFycmF5KVxuICB9XG5cbiAgbWFyc2hhbGwgKHZhbHVlOiBudW1iZXIsIG1lbW9yeU1hbmFnZXI6IE1lbW9yeU1hbmFnZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLmFsbG9jKG1lbW9yeU1hbmFnZXIpXG4gICAgbWVtb3J5TWFuYWdlci5kYXRhVmlldy5zZXRCaWdVaW50NjQoYWRkcmVzcywgdmFsdWUpXG4gICAgcmV0dXJuIGFkZHJlc3NcbiAgfVxuXG4gIHVubWFyc2hhbGwgKGFkZHJlc3M6IG51bWJlciwgbWVtb3J5TWFuYWdlcjogTWVtb3J5TWFuYWdlcik6IG51bWJlciB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBtZW1vcnlNYW5hZ2VyLmRhdGFWaWV3LmdldEJpZ1VpbnQ2NChhZGRyZXNzKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBtZW1vcnlNYW5hZ2VyLmZyZWUoYWRkcmVzcylcbiAgICB9XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5cbmltcG9ydCB7IE1lbW9yeU1hbmFnZXIgfSBmcm9tICcuLi9NZW1vcnlNYW5hZ2VyJ1xuXG5pbXBvcnQgeyBWYWx1ZVR5cGUgfSBmcm9tICcuL1ZhbHVlVHlwZSdcblxuZXhwb3J0IGNsYXNzIFVpbnQ4VHlwZSBleHRlbmRzIFZhbHVlVHlwZTxudW1iZXI+IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKFVpbnQ4QXJyYXkpXG4gIH1cblxuICBtYXJzaGFsbCAodmFsdWU6IG51bWJlciwgbWVtb3J5TWFuYWdlcjogTWVtb3J5TWFuYWdlcik6IG51bWJlciB7XG4gICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuYWxsb2MobWVtb3J5TWFuYWdlcilcbiAgICBtZW1vcnlNYW5hZ2VyLmRhdGFWaWV3LnNldFVpbnQ4KGFkZHJlc3MsIHZhbHVlKVxuICAgIHJldHVybiBhZGRyZXNzXG4gIH1cblxuICB1bm1hcnNoYWxsIChhZGRyZXNzOiBudW1iZXIsIG1lbW9yeU1hbmFnZXI6IE1lbW9yeU1hbmFnZXIpOiBudW1iZXIge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbWVtb3J5TWFuYWdlci5kYXRhVmlldy5nZXRVaW50OChhZGRyZXNzKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBtZW1vcnlNYW5hZ2VyLmZyZWUoYWRkcmVzcylcbiAgICB9XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5cbmltcG9ydCB7IE1lbW9yeU1hbmFnZXIgfSBmcm9tICcuLi9NZW1vcnlNYW5hZ2VyJ1xuXG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnLi9UeXBlJ1xuXG5leHBvcnQgY2xhc3MgVmFsdWVUeXBlPFQ+IGV4dGVuZHMgVHlwZTxUPiB7XG4gIGFsbG9jIChtZW1vcnlNYW5hZ2VyOiBNZW1vcnlNYW5hZ2VyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gbWVtb3J5TWFuYWdlci5tYWxsb2ModGhpcy5UeXBlZEFycmF5VHlwZS5CWVRFU19QRVJfRUxFTUVOVClcbiAgfVxuXG4gIGZyZWUgKGFkZHJlc3M6IG51bWJlciwgbWVtb3J5TWFuYWdlcjogTWVtb3J5TWFuYWdlcik6IHZvaWQge1xuICAgIG1lbW9yeU1hbmFnZXIuZnJlZShhZGRyZXNzKVxuICB9XG59XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnLi9UeXBlJ1xuXG5pbXBvcnQgeyBBcmd1bWVudERlZiB9IGZyb20gJy4vQXJndW1lbnREZWYnXG5cbmV4cG9ydCBjbGFzcyBJbjxUPiBleHRlbmRzIEFyZ3VtZW50RGVmPFQ+IHtcbiAgY29uc3RydWN0b3IgKHR5cGU6IFR5cGU8VD4pIHtcbiAgICBzdXBlcih0eXBlLCB0cnVlLCBmYWxzZSlcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgT3V0PFQ+IGV4dGVuZHMgQXJndW1lbnREZWY8VD4ge1xuICBjb25zdHJ1Y3RvciAodHlwZTogVHlwZTxUPikge1xuICAgIHN1cGVyKHR5cGUsIGZhbHNlLCB0cnVlKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBJbk91dDxUPiBleHRlbmRzIEFyZ3VtZW50RGVmPFQ+IHtcbiAgY29uc3RydWN0b3IgKHR5cGU6IFR5cGU8VD4pIHtcbiAgICBzdXBlcih0eXBlLCB0cnVlLCB0cnVlKVxuICB9XG59XG4iLCJleHBvcnQgeyBUeXBlIH0gZnJvbSAnLi9UeXBlJ1xuZXhwb3J0IHsgVmFsdWVUeXBlIH0gZnJvbSAnLi9WYWx1ZVR5cGUnXG5leHBvcnQgeyBJbnQ4VHlwZSB9IGZyb20gJy4vSW50OFR5cGUnXG5leHBvcnQgeyBJbnQxNlR5cGUgfSBmcm9tICcuL0ludDE2VHlwZSdcbmV4cG9ydCB7IEludDMyVHlwZSB9IGZyb20gJy4vSW50MzJUeXBlJ1xuZXhwb3J0IHsgSW50NjRUeXBlIH0gZnJvbSAnLi9JbnQ2NFR5cGUnXG5leHBvcnQgeyBVaW50OFR5cGUgfSBmcm9tICcuL1VpbnQ4VHlwZSdcbmV4cG9ydCB7IFVpbnQxNlR5cGUgfSBmcm9tICcuL1VpbnQxNlR5cGUnXG5leHBvcnQgeyBVaW50MzJUeXBlIH0gZnJvbSAnLi9VaW50MzJUeXBlJ1xuZXhwb3J0IHsgVWludDY0VHlwZSB9IGZyb20gJy4vVWludDY0VHlwZSdcbmV4cG9ydCB7IEZsb2F0MzJUeXBlIH0gZnJvbSAnLi9GbG9hdDMyVHlwZSdcbmV4cG9ydCB7IEZsb2F0NjRUeXBlIH0gZnJvbSAnLi9GbG9hdDY0VHlwZSdcbmV4cG9ydCB7IFJlZmVyZW5jZVR5cGUgfSBmcm9tICcuL1JlZmVyZW5jZVR5cGUnXG5leHBvcnQgeyBTdHJpbmdUeXBlIH0gZnJvbSAnLi9TdHJpbmdUeXBlJ1xuZXhwb3J0IHsgUG9pbnRlciB9IGZyb20gJy4vUG9pbnRlcidcbmV4cG9ydCB7IFBvaW50ZXJUeXBlIH0gZnJvbSAnLi9Qb2ludGVyVHlwZSdcbmV4cG9ydCB7IEFycmF5VHlwZSB9IGZyb20gJy4vQXJyYXlUeXBlJ1xuZXhwb3J0IHsgQXJndW1lbnREZWYgfSBmcm9tICcuL0FyZ3VtZW50RGVmJ1xuZXhwb3J0IHsgSW4sIE91dCwgSW5PdXQgfSBmcm9tICcuL2FyZ3VtZW50cydcbmV4cG9ydCB7IEZ1bmN0aW9uUHJvdG90eXBlIH0gZnJvbSAnLi9GdW5jdGlvblByb3RvdHlwZSdcbiIsIi8vIEBmbG93XG5cbmltcG9ydCB7IE1lbW9yeU1hbmFnZXIgfSBmcm9tICcuL01lbW9yeU1hbmFnZXInXG5pbXBvcnQgeyBXQVNJLCBTVERPVVQsIFNUREVSUiB9IGZyb20gJy4vY29uc3RhbnRzJ1xuXG5mdW5jdGlvbiBkcmFpbldyaXRlciAod3JpdGU6IChsaW5lOiBzdHJpbmcpID0+IHZvaWQsIHByZXY6IHN0cmluZywgY3VycmVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgbGV0IHRleHQgPSBwcmV2ICsgY3VycmVudFxuICB3aGlsZSAodGV4dC5pbmNsdWRlcygnXFxuJykpIHtcbiAgICBjb25zdCBbbGluZSwgcmVzdF0gPSB0ZXh0LnNwbGl0KCdcXG4nLCAyKVxuICAgIHdyaXRlKGxpbmUpXG4gICAgdGV4dCA9IHJlc3RcbiAgfVxuICByZXR1cm4gdGV4dFxufVxuXG4vLyBBbiBpbXBsZW1lbnRhdGlvbiBvZiBXQVNJIHdoaWNoIHN1cHBvcnRzIHRoZSBtaW5pbXVtXG4vLyByZXF1aXJlZCB0byB1c2UgbXVsdGkgYnl0ZSBjaGFyYWN0ZXJzLlxuZXhwb3J0IGNsYXNzIFdhc2kge1xuICBlbnY6IHsgW3N0cmluZ106IHN0cmluZyB9XG4gIGluc3RhbmNlOiA/V2ViQXNzZW1ibHkuSW5zdGFuY2VcbiAgbWVtb3J5TWFuYWdlcjogP01lbW9yeU1hbmFnZXJcbiAgc3Rkb3V0VGV4dDogc3RyaW5nXG4gIHN0ZGVyclRleHQ6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yIChlbnY6IHsgW3N0cmluZ106IHN0cmluZyB9KSB7XG4gICAgdGhpcy5lbnYgPSBlbnZcbiAgICB0aGlzLmluc3RhbmNlID0gbnVsbFxuICAgIHRoaXMubWVtb3J5TWFuYWdlciA9IG51bGxcbiAgICB0aGlzLnN0ZG91dFRleHQgPSAnJ1xuICAgIHRoaXMuc3RkZXJyVGV4dCA9ICcnXG4gIH1cblxuICAvLyBJbml0aWFsaXNlIHRoZSBpbnN0YW5jZSBmcm9tIHRoZSBXZWJBc3NlbWJseS5cbiAgaW5pdCAoaW5zdGFuY2U6IFdlYkFzc2VtYmx5Lkluc3RhbmNlKSB7XG4gICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlXG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIHRoaXMubWVtb3J5TWFuYWdlciA9IG5ldyBNZW1vcnlNYW5hZ2VyKFxuICAgICAgKGluc3RhbmNlLmV4cG9ydHMubWVtb3J5OiBhbnkpLFxuICAgICAgKGluc3RhbmNlLmV4cG9ydHMubWFsbG9jOiBhbnkpLFxuICAgICAgKGluc3RhbmNlLmV4cG9ydHMuZnJlZTogYW55KVxuICAgIClcbiAgfVxuXG4gIC8vIEdldCB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICBlbnZpcm9uX2dldCAoZW52aXJvbjogbnVtYmVyLCBlbnZpcm9uQnVmOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5lbnYpLm1hcChcbiAgICAgIChba2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmddKSA9PiBgJHtrZXl9PSR7dmFsdWV9YFxuICAgICkuZm9yRWFjaChlbnZWYXIgPT4ge1xuICAgICAgdGhpcy5tZW1vcnlNYW5hZ2VyLmRhdGFWaWV3LnNldFVpbnQzMihlbnZpcm9uLCBlbnZpcm9uQnVmLCB0cnVlKVxuICAgICAgZW52aXJvbiArPSA0XG5cbiAgICAgIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUoZW52VmFyKVxuICAgICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5tZW1vcnlNYW5hZ2VyLm1lbW9yeS5idWZmZXIsIGVudmlyb25CdWYsIGJ5dGVzLmxlbmd0aCArIDEpXG4gICAgICBlbnZpcm9uQnVmICs9IGJ1Zi5ieXRlTGVuZ3RoXG4gICAgfSlcbiAgICByZXR1cm4gV0FTSS5FU1VDQ0VTU1xuICB9XG5cbiAgLy8gR2V0IHRoZSBzaXplIHJlcXVpcmVkIHRvIHN0b3JlIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gIGVudmlyb25fc2l6ZXNfZ2V0IChlbnZpcm9uQ291bnQ6IG51bWJlciwgZW52aXJvbkJ1ZlNpemU6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG5cbiAgICBjb25zdCBlbnZWYXJzID0gT2JqZWN0LmVudHJpZXModGhpcy5lbnYpLm1hcChcbiAgICAgIChba2V5LCB2YWx1ZV0pID0+IGAke2tleX09JHt2YWx1ZX1gXG4gICAgKVxuICAgIGNvbnN0IHNpemUgPSBlbnZWYXJzLnJlZHVjZShcbiAgICAgIChhY2MsIGVudlZhcikgPT4gYWNjICsgZW5jb2Rlci5lbmNvZGUoZW52VmFyKS5ieXRlTGVuZ3RoICsgMSxcbiAgICAgIDBcbiAgICApXG4gICAgdGhpcy5tZW1vcnlNYW5hZ2VyLmRhdGFWaWV3LnNldFVpbnQzMihlbnZpcm9uQ291bnQsIGVudlZhcnMubGVuZ3RoLCB0cnVlKVxuICAgIHRoaXMubWVtb3J5TWFuYWdlci5kYXRhVmlldy5zZXRVaW50MzIoZW52aXJvbkJ1ZlNpemUsIHNpemUsIHRydWUpXG5cbiAgICByZXR1cm4gV0FTSS5FU1VDQ0VTU1xuICB9XG5cbiAgLy8gVGhpcyBnZXRzIGNhbGxlZCBvbiBleGl0IHRvIHN0b3AgdGhlIHJ1bm5pbmcgcHJvZ3JhbS5cbiAgLy8gV2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBzdG9wIVxuICBwcm9jX2V4aXQgKHJ2YWw6IG51bWJlcikge1xuICAgIHJldHVybiBXQVNJLkVTVUNDRVNTXG4gIH1cblxuICBmZF9jbG9zZSAoZmQ6IG51bWJlcikge1xuICAgIHJldHVybiBXQVNJLkVTVUNDRVNTXG4gIH1cblxuICBmZF9zZWVrIChmZDogbnVtYmVyLCBvZmZzZXRfbG93OiBudW1iZXIsIG9mZnNldF9oaWdoOiBudW1iZXIsIHdoZW5jZTogbnVtYmVyLCBuZXdPZmZzZXQ6IG51bWJlcikge1xuICAgIHJldHVybiBXQVNJLkVTVUNDRVNTXG4gIH1cblxuICBmZF93cml0ZSAoZmQ6IG51bWJlciwgaW92czogbnVtYmVyLCBpb3ZzTGVuOiBudW1iZXIsIG53cml0dGVuOiBudW1iZXIpIHtcbiAgICBpZiAoIShmZCA9PT0gMSB8IGZkID09PSAyKSkge1xuICAgICAgcmV0dXJuIFdBU0kuRVJSTk8uQkFERlxuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlcnMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBpb3ZzTGVuIH0sIChfLCBpKSA9PiB7XG4gICAgICBjb25zdCBwdHIgPSBpb3ZzICsgaSAqIDhcbiAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMubWVtZW9yeU1hbmFnZXIuZGF0YVZpZXcuZ2V0VWludDMyKHB0ciwgdHJ1ZSlcbiAgICAgIGNvbnN0IGJ1ZkxlbiA9IHRoaXMubWVtZW9yeU1hbmFnZXIuZGF0YVZpZXcuZ2V0VWludDMyKHB0ciArIDQsIHRydWUpXG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5tZW1vcnlNYW5hZ2VyLm1lbW9yeS5idWZmZXIsIGJ1ZiwgYnVmTGVuKVxuICAgIH0pXG5cbiAgICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG5cbiAgICBsZXQgd3JpdHRlbiA9IDBcbiAgICBsZXQgdGV4dCA9ICcnXG4gICAgYnVmZmVycy5mb3JFYWNoKGJ1ZiA9PiB7XG4gICAgICB0ZXh0ICs9IHRleHREZWNvZGVyLmRlY29kZShidWYpXG4gICAgICB3cml0dGVuICs9IGJ1Zi5ieXRlTGVuZ3RoXG4gICAgfSlcbiAgICB0aGlzLm1lbWVvcnlNYW5hZ2VyLmRhdGFWaWV3LnNldFVpbnQzMihud3JpdHRlbiwgd3JpdHRlbiwgdHJ1ZSlcblxuICAgIGlmIChmZCA9PT0gU1RET1VUKSB7XG4gICAgICB0aGlzLnN0ZG91dFRleHQgPSBkcmFpbldyaXRlcihjb25zb2xlLmxvZywgdGhpcy5zdGRvdXRUZXh0LCB0ZXh0KVxuICAgIH0gZWxzZSBpZiAoZmQgPT09IFNUREVSUikge1xuICAgICAgdGhpcy5zdGRlcnJUZXh0ID0gZHJhaW5Xcml0ZXIoY29uc29sZS5lcnJvciwgdGhpcy5zdGRlcnJUZXh0LCB0ZXh0KVxuICAgIH1cblxuICAgIHJldHVybiBXQVNJLkVTVUNDRVNTXG4gIH1cblxuICBmZF9mZHN0YXRfZ2V0IChmZDogbnVtYmVyLCBzdGF0OiBudW1iZXIpIHtcbiAgICBpZiAoIShmZCA9PT0gMSB8IGZkID09PSAyKSkge1xuICAgICAgcmV0dXJuIFdBU0kuRVJSTk8uQkFERlxuICAgIH1cbiAgICBpZiAodGhpcy5tZW1vcnlNYW5hZ2VyID09IG51bGwgfHwgdGhpcy5tZW1vcnlNYW5hZ2VyLmRhdGFWaWV3ID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtZW1vcnknKVxuICAgIH1cblxuICAgIHRoaXMubWVtb3J5TWFuYWdlci5kYXRhVmlldy5zZXRVaW50OChzdGF0ICsgMCwgV0FTSS5GSUxFVFlQRS5DSEFSQUNURVJfREVWSUNFKVxuICAgIHRoaXMubWVtb3J5TWFuYWdlci5kYXRhVmlldy5zZXRVaW50MzIoc3RhdCArIDIsIFdBU0kuRkRGTEFHUy5BUFBFTkQsIHRydWUpXG4gICAgdGhpcy5tZW1vcnlNYW5hZ2VyLmRhdGFWaWV3LnNldEJpZ1VpbnQ2NChzdGF0ICsgOCwgV0FTSS5SSUdIVFMuRkRfV1JJVEUsIHRydWUpXG4gICAgdGhpcy5tZW1vcnlNYW5hZ2VyLmRhdGFWaWV3LnNldEJpZ1VpbnQ2NChzdGF0ICsgMTYsIFdBU0kuUklHSFRTLkZEX1dSSVRFLCB0cnVlKVxuICAgIHJldHVybiBXQVNJLkVTVUNDRVNTXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=